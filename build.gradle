/*
 * Gradle build for Jython. See also settings.gradle.
 *
 * This is an attempt to build a distributable JAR using Gradle that could be
 * cited as a dependency by other Gradle or Maven projects, when they use the
 * Jython interpreter from Java (under JSR-223 or directly).
 *
 * At present, the build is additional to the Ant build that remains the
 * primary and reliable support for development, for test, and to build the
 * Jython installers.
 *
 * The delivered jar should contain only Jython project material (Java classes
 * and the Python library) while the many JARs Jython depends on will be cited
 * in the accompanying metadata as dependencies.
 *
 * The Jython source structure does not follow the standard convention for
 * Gradle. This script deals with that without changing it, but it uses a build
 * directory (build2) entirely separate from Ant's, in which generated and
 * compiled material is posted conformant with Gradle conventions. This means
 * that the later tasks Gradle provides (test and jar) do not need so much
 * customisation.
 */

plugins {
    id 'java-library'
    id 'antlr'
    id 'maven-publish'
}

import java.text.SimpleDateFormat

// ---------------- Determine the version of Jython ----------------------------

/*
 * This one string will be used to name the generated JAR and version-stamp the
 * application. It should be all you have to edit to version a release built
 * here. But of course you have to do it the hard way too (see build.xml) as
 * long as Ant is also used.
 */
// <major> . <minor> ( . <micro> )? ( <release> <serial> )? ([-+] <word>? )?

version = '2.7.2a1+'

// Valid examples (please preserve in comments):
//version = '2.7.2a2'
//version = '2.7.2b1'
//version = '2.7.2rc1'
//version = '2.7.2'

group = 'org.python'


// ---------------- Miscellaneous configuration --------------------------------


// Separate the Gradle build from that of Ant
buildDir = file('build2')
ext {
    buildDate = new Date()
    // Java source generated by ANTLR
    antlrGenDir = "$buildDir/gensrc/org/python/antlr"
    // This is where we assemble the standard library pre-JAR
    buildLibDir = "$buildDir/resources/main/Lib/"
    compiledLibDir = "$buildDir/classes/main/Lib/"
}


repositories {
    /*
     * Jython is distributed through Maven Central. Get our dependencies there
     * too.
     */
    mavenCentral()
}

sourceSets {

    main {  // Non-standard locations must be specified explicitly

        antlr {
            srcDirs = ['grammar']
            exclude 'Base.g' // Not used (and produces errors)
        }

        java {
            srcDirs = ['src', project.ext.antlrGenDir]
            exclude 'com/**'    // for now
        }

        // output.resourcesDir = project.ext.assemblyDir

        resources {
            // Resources in project root, but this invites an explosion:
            // srcDirs = ['']
            // ... so claim no sources:
            srcDirs = []
            // and fix it in task processResources
        }
    }

    test {  // Non-standard locations must be specified explicitly

        java {
            srcDirs = ['tests/java']
            exclude 'com/**'    // XXX for now
        }
    }
}

dependencies {
    /*
     * These must correspond fairly exactly with the external libraries (JARs)
     * mentioned in the Ant build.xml.
     */

    // Using a version available from repo (not 'extlibs/servlet-api-2.5' as in build.xml)
    implementation group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0'

    // implementation 'mysql-connector-java-5.1.42-bin'
    // implementation 'postgresql-42.1.1.jre7'

    // pin to Antlr 3.1.3 until we upgrade parsing
    antlr 'org.antlr:antlr:3.1.3' // use ANTLR version 3
    implementation 'org.antlr:antlr-runtime:3.1.3'
    implementation 'org.antlr:stringtemplate:3.2.1'

    implementation group: 'org.apache.commons', name: 'commons-compress', version: '1.14'

    // pin to ASM 5.2 until we upgrade compilation
    implementation group: 'org.ow2.asm', name: 'asm', version: '5.2'
    implementation group: 'org.ow2.asm', name: 'asm-commons', version: '5.2'
    implementation group: 'org.ow2.asm', name: 'asm-util', version: '5.2'

    implementation group: 'com.google.guava', name: 'guava', version: '22.0-android'
    implementation group: 'com.ibm.icu', name: 'icu4j', version: '59.1'

    implementation group: 'com.carrotsearch', name: 'java-sizeof', version: '0.0.5'

    implementation group: 'com.github.jnr', name: 'jffi', version: '1.2.16'
    implementation group: 'com.github.jnr', name: 'jnr-netdb', version: '1.1.6'
    implementation group: 'com.github.jnr', name: 'jnr-ffi', version: '2.1.7'
    implementation group: 'com.github.jnr', name: 'jnr-posix', version: '3.0.44'
    implementation group: 'com.github.jnr', name: 'jnr-constants', version: '0.9.9'

    implementation group: 'jline', name: 'jline', version: '2.14.5'

    implementation group: 'io.netty', name: 'netty-buffer', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-codec', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-common', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-handler', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-resolver', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-transport', version: '4.1.24.Final'

    // Used implicitly in the Ant build, must be explicit here
    implementation group: 'org.apache.ant', name: 'ant', version: '1.9.7'

    testImplementation group: 'junit', name: 'junit', version: '4.10'

}

// ---------------- Resource Processing ----------------------------------------

/*
 * Jython brings several files we could treat as resources, but they do not sit
 * in the Gradle-conventional 'main/resources' directory, rather are in the
 * project root or rub shoulders with the java source. Pick them individually.
 */
processResources {
    from(file('.')) {
        include 'LICENSE.txt'
    }
    from(file('src')) {
        include 'META-INF/**'
        include 'org/python/modules/ucnhash.dat'
    }
}

// ---------------- ANTLR Task -------------------------------------------------

generateGrammarSource {
    maxHeapSize = "512m"
    outputDirectory = file(project.ext.antlrGenDir)
}

// ---------------- Expose Task ------------------------------------------------

/*
 * The exposer operates between two (somewhat fixed) directories. We follow
 * the Gradle-conventional directory structure (not the legacy one).
 */
ext {
    compileDir = "$buildDir/classes/java/main/"
    exposedDir = "$buildDir/classes/exposed/main/"
}

configurations {
    expose.extendsFrom(implementation)
}

dependencies {
    // Put our compiled classes on the path of the expose (Ant) task
    expose files("$buildDir/classes/java/main")
}

// A (Gradle) task to run the Ant task 'expose'.
task expose (group: 'Custom', dependsOn: compileJava) {

    description = 'Expose Java types to Python using their annotations.'

    // Allow Gradle to infer the need to regenreate the outputs
    inputs.files(fileTree("${project.ext.compileDir}/org/python"))
    outputs.dir(project.ext.exposedDir)

    doLast {
        /*
         * Define an Ant task called 'expose' in the project's AntBuilder.
         * We can't define it until ExposeTask has been compiled.
         */
        ant.taskdef(
            name: 'expose',
            classname: 'org.python.expose.generate.ExposeTask',
            classpath: configurations.expose.asPath
         )

        // Use the Gradle-conventional directory structure (not the legacy one).
        ant.expose(
            srcdir: file(project.ext.compileDir),
            destdir: mkdir(file(project.ext.exposedDir)),
            includesfile: file('CoreExposed.includes')
        )
    }
}

// ---------------- Version-related file generation ----------------------------

/*
 * Write the information that org.python.Version reads from
 * org/python/version.properties in the class file structure. The inputs to
 * this are: information from Mercurial (hg command required); project.version;
 * and project.ext.buildDate. The task works quite hard to decode
 * project.version, which must have the correct form, to deduce whether you
 * really intend this to be a release. If anything comes after the release
 * number, typically it's a '+' sign, the version becomes a snapshot.
 */
task generateVersionInfo(
        type: WriteProperties,
        description: 'Write the version information as properties') {

    outputFile = file("${processResources.destinationDir}/org/python/version.properties")
    comment = ' Jython version information (from build.gradle)'

    // Create the properties when the task runs. But do it before the write!
    doFirst {
        /*
         * Query Mercurial for version and tagging.
         */
        String hgOutput = 'hg identify -ibt'.execute().text
        hgOutput = hgOutput.split('\n', 2)[0]

        // <revision-id>(+)? <branch> <tag>
        String[] parts = hgOutput.split(/\s+/, 3)
        if (parts.length != 3) {
            throw new IllegalArgumentException(
                    "Cannot split Mercurial output '$hgOutput' into 3")
        }
        def (ident, branch, tag) = parts
        property('jython.build.hg_branch', branch)
        property('jython.build.hg_tag', tag)
        property('jython.build.hg_version', ident)

        /*
         * Decompose the version string into elements for Jython to access as
         * properties. (The Ant build.xml requires them to be set in parts, but
         * we can work it out from the .)
         */
        // <major>.<minor>(.<micro>)(<release><serial>)?([-+]<snapshot>)?
        def versionRegex = /(\d+)\.(\d+)(\.(\d+))?((a|b|rc)(\d+))?([-+]\w*)?/
        def versionMatcher = project.version =~ versionRegex
        if (versionMatcher.count != 1) {
            throw new IllegalArgumentException(
                    "Cannot parse project version string '${project.version}'")
        }
        // In principle it could match more than once: take the leftmost
        def versionResult = versionMatcher[0]


        // Useful debug
        /*
        for (int i=0; i < versionResult.size(); i++) {
            String part = versionResult[i]
            println "versionResult[$i] = $part"
        } */

        // <major>.<minor> means <major>.<minor>.0
        String major = versionResult[1]
        String minor = versionResult[2]
        String micro = versionResult[3] ? versionResult[4] : '0'

        // Convert the optional <release><serial> to numbers
        int SNAPSHOT = 0xaa
        int level = 0, serial = 0
        if (versionResult[5]) {
            // This is some kind of pre-final release (unless snapshaot)
            serial = versionResult[7] as int
            switch (versionResult[6]) {
                case 'a': level = 0xa; break // ALPHA release
                case 'b': level = 0xb; break // BETA release
                case 'rc': level = 0xc; break // release candidate
            }
        } else {
            // Not marked as a/b/rc so ostensibly a final release.
            level = 0xf
        }

        // Except, if there was something after the version we decoded ...
        if (versionResult[8]) {
            level = SNAPSHOT // it's snapshot or dev version of some kind
            serial = 0
        }

        property('jython.version', project.version)
        property('jython.major_version', major)
        property('jython.minor_version', minor)
        property('jython.micro_version', micro)
        property('jython.release_level', level)
        property('jython.release_serial', serial)

        /*
         * Time-stamp the build. In the time part, the ':' gets escaped to
         * '\:', consistent with Properties.store(), unlike the Ant build.
         */
        property('jython.build.time',
                (new SimpleDateFormat('HH:mm:ss'))
                .format(project.ext.buildDate))
        property('jython.build.date',
                (new SimpleDateFormat('MMM d yyyy'))
                .format(project.ext.buildDate))

        /*
         * Remind the developer about tagging it if it looks like a release,
         * or to adjust project.version if we're moving on from the release.
         */
        if (level != SNAPSHOT) {
            def L = [0:'', 10:'a', 11:'b', 12:'rc', 15:'']
            String release = "$major.$minor.$micro${L[level]}${serial?:''}"
            println "This build is versioned for distribution as $release"
            if (tag == 'tip' || ident.endsWith('+')) {
                println "If this really is distributable, " +
                        "don't forget to tag it in the repository.\n" +
                        "Alternatively, add a suffix to version = " +
                        "'${project.version}' in build.gradle to shut this up."
            }
        }
    }
}

// Attach this task to processResources
processResources.dependsOn(generateVersionInfo)


// ---------------- Copy Python Library ----------------------------------------

/*
 * The default behaviour of the Java plug-in is to make a JAR of the classes in
 * the "main" source set. We need a more complex assembly that provides users
 * with exposed classes instead of their plain counterparts, and also various
 * configuration files and the Python library.
 *
 * These copies include the tests, so we can test things :), but a subsequent
 * JarTask of the build should exclude them as necessary. (Not yet implemented.)
 */

ext {
    libPython = 'lib-python/2.7'
    libJython = 'Lib'
}


/*
 * Copy the Python standard library. We take this from a distribution of
 * CPython, but take only the files specified in CPythonLib.includes in the
 * project root.
 */
task copyLib(
        type: Copy,
        description: 'Merge lib-python and Jython Lib during assembly') {

    into "${project.ext.buildLibDir}"

    // Copy Jython Lib, with precedence over CPython files of the same name
    from file(project.ext.libJython)
    exclude 'test/'
    exclude '**/*.class'
    duplicatesStrategy = DuplicatesStrategy.INCLUDE

    // Allow Gradle to infer the need to regenerate the outputs
    inputs.dir project.ext.libJython
    inputs.dir project.ext.libPython
    inputs.file file('CPythonLib.includes')
    outputs.dir project.ext.buildLibDir

    doFirst {
        // Select the CPython stdlib files by making a list.
        def cPythonLibIncludes = []
        // Read list from CPythonLib.includes, stripping comments and spaces.
        file('CPythonLib.includes').eachLine { line ->
            def trimmed = line.split('#', 2)[0].trim()
            if (trimmed.length() > 0) {
                cPythonLibIncludes << trimmed
            }
        }
        // Copy the subset as specified by the list
        project.copy {
            from file(project.ext.libPython)
            include cPythonLibIncludes
            exclude '**/*.pyc', '**/*.pyd'
            into project.ext.buildLibDir
            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        }
    }

    /*
    <target name="copy-cpythonlib">
        <copy todir="${dist.dir}/Lib">
            <fileset dir="${python.lib}" excludes="** /*.pyc, ** /*.pyo"
                    includesfile="${jython.base.dir}/CPythonLib.includes">
                <!-- The include file gets all of lib-python/2.7's test directory, but we only want the ones from Jython's Lib.   -->
                <present present="srconly" targetdir="${jython.base.dir}/Lib"/>
            </fileset>
        </copy>
    </target>
    */
}




// ---------------- Jython-Compile Python --------------------------------------

/*
 * Compile the Python modules to .class files for the JAR. Whereas Jython runs
 * happily with a concrete Lib folder, creating and caching the .class files,
 * when Jython is supplied as a JAR, we prefer to compile the class files once
 * in advance.
 */

configurations {
    pycompile.extendsFrom(implementation)
}

dependencies {
    // Jython as built so far should be on the path of the jycompile (Ant) task
    pycompile files("$buildDir/classes/exposed/main")
    pycompile files("$buildDir/classes/java/main")
    pycompile files("$buildDir/resources/main")
}

// A (Gradle) task to run the Ant task 'jycompile' (not pycompile).
task pycompile(
        group: 'Custom',
        description: 'Compile the Python modules to .class files for the JAR') {

    dependsOn compileJava
    dependsOn expose
    dependsOn copyLib

    // Allow Gradle to infer the need to regenerate the outputs
    inputs.dir project.ext.buildLibDir
    outputs.dir project.ext.compiledLibDir

    doFirst {
        /*
         * Define an Ant task called 'jycompile' in the project's AntBuilder.
         * We can't define it until JythoncAntTask has been compiled, so this
         * must happen during the execution of the task (early).
         */
         ant.taskdef(
            name: 'jycompile',
            classname: 'org.python.util.JycompileAntTask',
            classpath: configurations.pycompile.asPath
         )
    }

    doLast {
        /*
         * Now use the 'jycompile' Ant task tocompile the Python source we
         * supply to users. The exclusions are copied from build.xml, as also
         * is this comment:
            <!-- One might think that the exclusion of lib2to3/tests/** is
                 recursive, but one would be wrong ;) It's actually only
                 two levels, so for now the workaround is to also include
                 data/myfixes/**

                 This exclusion for lib2to3/tests/ in general is necessary
                 because data/infinite_recursion.py is not compileable by
                 Jython - it's too large and will exceed Java method
                 limits for the top level script; nor is
                 data/py3_test_grammar.py - it's Python 3. Meanwhile
                 refactor.get_all_fix_names depends on having *.py, not
                 exclusively $py.class, files available in
                 lib2to3/tests/data/myfixes/**. -->
         */
        def exclusions = ['test/**', 'lib2to3/tests/**',
            'lib2to3/tests/data/myfixes/**']
        ant.jycompile(
            srcdir: project.ext.buildLibDir,
            destdir: project.ext.compiledLibDir,
            excludes: exclusions.join(',')    // Yes, it's that way round :o
        )
    }

}


// ---------------- Building the JAR -------------------------------------------

/*
 * The default behaviour of the Java plug-in is to make a JAR of the classes in
 * the "main" source set. We need a more complex operation that provides users
 * with exposed classes instead of their plain counterparts, and also various
 * configuration files and the Python library.
 *
 * Much of the assembly has taken place already in selective copying to the
 * build directory by tasks processResources and copyLib.
 */
task jar(type: Jar, overwrite: true) {

    dependsOn pycompile

    /*
     * This is a custom replacement Jar task so that we may control the
     * order of adding classes. Exposed versions of identically-named classes
     * supersede (by arriving first) those directly from compilation.
     */
    exclude 'org/python/expose/generate/**' // The expose tool itself

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    preserveFileTimestamps = true

    // Add the exposed classes to the JAR
    from expose

    // Add other compiled classes
    from compileJava

    // Add the resources (includes merged Python library)
    from processResources

    // Add compiled Python library
    from file(project.ext.compiledLibDir).parent

    manifest {
        // These attribute values are based on inspecting the ant build
        attributes ([
            'Main-Class': 'org.python.util.jython',
            'Built-By': 'build.gradle',
        ])

        attributes( [ // Build-Info section
            'version': project.version,
            'build-compiler': 'modern',
            'jdk-target-version': '1.7',
            'debug': true,
        ], 'Build-Info' )
    }

}


// ---------------- Documentation ----------------------------------------------

/*
 * JavaDoc, anyway.
 */

javadoc {
    options.encoding = 'UTF-8'
}

// ---------------- Publication ------------------------------------------------

/*
 * Post the JAR we built to a public repository. We provide secondary -source
 * and -javadoc JARs too (supporting 'main').
 *
 * How do we test the artifact actually published is correct? The 'test' task
 * tests Jython laid out in the build directory, not the JAR we propose to
 * distribute.
 *
 * Maybe have a second JAR that contains the additional material necessary to
 * run integration tests (regression tests and others). Python tests are
 * (incorrectly) in the main JAR at present.
 */

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allJava
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

publishing {

    publications {
        // The production JAR we expect to be cited as a dependency by users
        main(MavenPublication) {
            
            // Correctly-constructed jar but a .pom without dependencies:
            artifact jar

            // Nice .pom but the jar is the default built by the Java plugin:
            //from components.java
            
            // Also provide the source.
            artifact sourcesJar
            // Also provide the docs. (Some javadoc errors currntly.)
            artifact javadocJar
        }
    }

    repositories {
        // Dummy one for test: need sonatype here and credentials from user
        maven {
            name = 'myRepo'
            url = "file://${buildDir}/repo"
        }
    }
}


// ---------------- Java unit tests --------------------------------------------

ext {
    //distDir = relativePath("$buildDir/assembly")
    testSourceDir = relativePath('tests/java')
}


dependencies {
    // Put the exposed classes on the path of the test tasks
    testImplementation files(expose)
}

// Ensure exposed classes are ahead of standard path
sourceSets.test {
    compileClasspath  = files(expose.outputs) + compileClasspath
    runtimeClasspath = files(expose.outputs) + runtimeClasspath
    // println "runtimeClasspath = ${runtimeClasspath.asPath}"
}

compileTestJava {
    dependsOn expose
}

test {

    dependsOn copyLib

    // Stop on first test failure
    failFast = true

    // Properties as defined in Ant target javatest-basepath
    //systemProperty 'python.home', project.ext.distDir
    // XXX Not sure of all that python.home is used for in tests.
    systemProperty 'python.home', file(copyLib.destinationDir).parent
    systemProperty 'python.test.source.dir', project.ext.testSourceDir
    // Place cache outside the targets for jar task
    systemProperty 'python.cachedir', "${project.buildDir}/cachedir"

    // Include/exclude based on Ant target javatest-basepath
    include '**/*Test*'
    exclude '**/InterpTestCase'
    exclude '**/jythonTest*'            // Must run interactively
    exclude 'org/python/antlr/**'
    exclude 'org/python/tests/imp/**'   // See build.xml:importest

    // Some additional exclusions or else the task fails

    // FIXME: leaves stdin/out/err as PyFileWriter that has no fileno()
    // causing _ioTest to fail.
    exclude '**/jsr223/*'

    // FIXME: Tests that hard-code directory paths (use a symbol):
    exclude 'org/python/compiler/custom_proxymaker/**'
    exclude 'org/python/compiler/JavaMakerSmokeTest.class'

    // FIXME: Failing test finds project root from test class location
    exclude 'org/python/core/PySystemState_registry_Test.class'

    // FIXME: Fails as sys._jy_console not set when run under Gradle
    exclude 'org/python/util/InterpreterTest.class'

    doFirst {
        println "systemProperties = $systemProperties"
    }

    /* From build.xml :

    <target name="javatest-basepath" depends="developer-build">
        <mkdir dir="${junit.reports}"/>
        <junit fork="true" printsummary="true">
            <formatter type="xml"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <batchtest todir="${junit.reports}" skipNonTests="true">
                <fileset dir="${test.source.dir}" includes="** /*Test*.java">
                    <exclude name="** /InterpTestCase.java" />
                    <exclude name="** /jythonTest*" /> <!-- Must run interactively -->
                    <exclude name="org/python/antlr/**" />
                    <exclude name="org/python/tests/imp/**" /> <!-- See importest -->
                    <exclude name=".classpath" />
                    <exclude name=".project" />
                </fileset>
            </batchtest>
        </junit>
    </target>

    <target name="importest" depends="developer-build" description="run all the JUnit tests that need tests/python in the path.">
        <mkdir dir="${junit.reports}"/>
        <junit fork="true" printsummary="true">
            <formatter type="xml"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <classpath refid="test.classpath"/>
            <classpath>
                <pathelement location="${jython.base.dir}/tests/python"/>
            </classpath>
            <batchtest todir="${junit.reports}">
                <fileset dir="${test.source.dir}" includes="org/python/tests/imp/*Test*.java">
                </fileset>
            </batchtest>
        </junit>
    </target>

    */
}


// ---------------- Miscellaneous fettling of the prepare phase ----------------

// Source is globally UTF-8 (well, nearly).
tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
}



// ---------------- Tasks for debugging ----------------------------------------


task dumpCP {
    doLast {
        //println('configurations.testCompile:')
        //configurations.testCompile.each { println it }
        //println('configurations.testRuntime:')
        //configurations.testRuntime.each { println it }
        println('configurations.expose:')
        configurations.expose.each { println it }
        println('configurations.pycompile:')
        configurations.pycompile.each { println it }
    }
}

task dumpCompo {
    doLast {
        println('components:')
        components.each { println it }
        println('components.java:')
        components.java.each { println it }
    }
}

task dumpArt {
    doLast {
        println('artifacts:')
        artifacts.each { println it }
    }
}

task dumpArch {
    doLast {
        println('archives:')
        configurations.archives.each { println it }
    }
}

task dumpex {
    // Legacy approach to obtaining files to JAR
    doLast {
        int n = project.ext.exposedDir.length()
        Set<String> exposedClasses = new TreeSet()
        //println "*** files in ${project.ext.exposedDir}:"
        for (f in fileTree(project.ext.exposedDir)) {
            //println project.relativePath(f).substring(n)
            exposedClasses.add( project.relativePath(f).substring(n) )
        }
        //for (f in exposedClasses) { println f }

        println "${fileTree(project.ext.compileDir).size()} compiled classes."

        n = project.ext.compileDir.length()
        int countx = 0
        for (f in fileTree(project.ext.compileDir)) {
            //println project.relativePath(f).substring(n)
            String name = project.relativePath(f).substring(n)
            if (name in exposedClasses) { countx += 1 }
        }
        println "${exposedClasses.size()} classes from ${countx} exposed."

        def compiledToJar = fileTree(project.ext.compileDir).filter({
            File f -> !(project.relativePath(f).substring(n) in exposedClasses)
        })

        println "${compiledToJar.size()} to be jarred (after filtering)."

        int counti = 0
        for (f in fileTree(project.ext.compileDir)) {
            String name = project.relativePath(f).substring(n)
            String exposed = (name in exposedClasses) ? "EXPOSED" : ""
            // println "${name} ${exposed}"
            if (exposed) { counti += 1 }
        }

        println "${counti} in overlap."
    }
}


task dumpSS {
    doLast {
        // Debug
        println '*** source sets ***'
        for ( sourceSet in sourceSets ) {
            println "  ${sourceSet}"
            // for ( name in sourceSet.asMap.keys ) {
                // sourceDirectorySet = sourceSet.asMap[name]
                // println "    $name = $sourceDirectorySet"
            // }
        }
    }
}