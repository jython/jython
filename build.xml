<!--
    Original Copyright 2000 Dj Walker-Morgan
    Further development (c)2019 Jython Developers
    Licensed to the PSF under a Contributor Agreement.
-->
<project name="jython" default="developer-build" basedir=".">

    <target name="usage" depends="common-version-strings"
            description="print usage hints (-emacs removes [echo] prefix)">
        <echo>
Case 1: developer build
-----------------------
Use the command:
    ant developer-build
or just:
    ant
as it is the default target. This build will create directories
/build and /dist below ${basedir}.
Jython will identify its version with a trailing "-DEV".

Case 2: build an installer for the development version
------------------------------------------------------
Use the command:
  ant installer
An installer built this way does not include javadoc or source
JARs unless you build them first. It will be versioned as a
snapshot, e.g. ${jython.release}-SNAPSHOT. You can choose another name
for the snapshot, via a property:
  ant -Dsnapshot.name=MYTEST installer

Case 3: full build for a release (use clean, tagged checkout)
-------------------------------------------------------------
You do not have to have access to the Jython Git
repository, but you do need to be at the root of a checked-out
(i.e. newly cloned) source tree. The release aretefacts will be
marked as a snapshot (not an official release) if any of the
following apply:
- there is no .git directory (this is not a repo),
- the source tree contains any extraneous files,
- files have been edited and not committed,
- the current state is not tagged with correct release,
- you supply the snapshot.name property.

This will create a big jython-installer-${jython.release}.jar,
in the artefacts directory.

See also https://jython-devguide.rtfd.io/en/latest/release_jy.html

Note on targets
---------------
A subset of the available targets are designed for direct invocation.
Following an ant convention, the callable targets have a description
attribute.  Use ant -p to display these targets.  All other targets
may behave unpredictably if called directly.

Where ant looks for ant.properties
----------------------------------
  1. in user.home
  2. in the same directory as this build.xml file
The first setting of a property wins. Further settings are ignored.

An example ant.properties file:
-------------------------------

# - zxJDBC
oracle.jar = ../support/ojdbc6.jar
informix.jar = ../support/jdbc-4.10.12.jar

# - option for javac (build.compiler=modern is a global option to use standard jdk 1.8)
#build.compiler=modern
#jdk.target.version=1.8
#debug=false
#deprecation=off
        </echo>
    </target>

    <target name="developer-build"
            depends="jar, jar-test, copy-dev, pycompile"
            description="a local build for developers" />

    <target name="installer"
            depends="installer-preinit, jar-installer"
            description="build a snapshot installer from the current state" />

    <target name="full-build"
            depends="clean, full-preinit, full-check, all-jars, jar-installer"
            description="build releasable artefacts. (Use a fresh checkout for a real release)" />

    <target name="common-config" depends="common-constants">
        <!-- Initialisations common to full and developer builds. -->

        <property file="${user.home}/ant.properties" />
        <property file="${basedir}/ant.properties" />
        <property name="jython.java.version" value="1.8" />
        <property name="jdk.source.version" value="1.8" />

        <!-- Designate the official release encoded in parts. In normal times, this is the *next*
             official release, e.g. 2.7.2b2 while working towards 2.7.2b2, and sys.version will be
             "2.7.2b2-DEV". To build that release, work in a clean checkout of the corresponding
             tag. Until then sys.version will have a snapshot suffix (-DEV or -SNAPSHOT). You can
             specify that suffix by -Dsnapshot.name on the ant command line. -->
        <property name="jython.major_version" value="2"/>
        <property name="jython.minor_version" value="7"/>
        <property name="jython.micro_version" value="4"/>
        <property name="jython.release_level" value="${PY_RELEASE_LEVEL_ALPHA}"/>

        <!-- Zero at full release: one-up number for alpha, beta and candidate versions. -->
        <property name="jython.release_serial" value="1"/>
    </target>

    <target name="common-constants">
        <!-- Constants for relese levels (defined by Python)  -->
        <property name="PY_RELEASE_LEVEL_ALPHA" value="10"/> <!-- 0xA -->
        <property name="PY_RELEASE_LEVEL_BETA" value="11"/> <!-- 0xB -->
        <property name="PY_RELEASE_LEVEL_GAMMA" value="12"/> <!-- 0xC -->
        <property name="PY_RELEASE_LEVEL_FINAL" value="15"/> <!-- 0xF -->
    </target>

    <target name="common-version-strings" depends="common-config">
        <!-- Compose version strings we need, but not the "snapshot" suffix. -->
        <property name="jython.version.short"
             value="${jython.major_version}.${jython.minor_version}.${jython.micro_version}" />
        <!-- The release level visible in the JAR needs a string form -->
        <condition property="jython.release.str" value="a">
            <equals arg1="${jython.release_level}" arg2="${PY_RELEASE_LEVEL_ALPHA}" />
        </condition>
        <condition property="jython.release.str" value="b">
            <equals arg1="${jython.release_level}" arg2="${PY_RELEASE_LEVEL_BETA}" />
        </condition>
        <condition property="jython.release.str" value="rc" else="">
            <equals arg1="${jython.release_level}" arg2="${PY_RELEASE_LEVEL_GAMMA}" />
        </condition>
        <!-- And the release serial too -->
        <condition property="jython.release.num" value="" else="${jython.release_serial}">
            <or>
                <equals arg1="${jython.release_serial}" arg2="0" />
                <equals arg1="${jython.release.str}" arg2="" />
            </or>
        </condition>
        <!-- Finally the target version (last or next release) without snapshot suffix -->
        <property name="jython.release"
            value="${jython.version.short}${jython.release.str}${jython.release.num}" />
    </target>

    <target name="common-dirs">
        <!-- There are several points of reference. The first is the base of the source code: -->
        <property name="source.dir" value="${basedir}/src" />
        <property name="templates.dir" value="${source.dir}/templates" />
        <property name="templates.lazy" value="true" />
        <property name="installer.src.dir" value="${basedir}/installer/src/java" />

        <!-- The stdlib from CPython and JARs we import: -->
        <property name="python.lib" value="${basedir}/lib-python/2.7" />
        <property name="extlibs.dir" value="${basedir}/extlibs" />

        <!-- Cache we need to clean (now it is not in dist.dir) -->
        <property name="cache.dir" value="${basedir}/.jython_cache" />

        <!-- Source specifically for test: -->
        <property name="test.source.dir" value="${basedir}/tests/java" />
        <property name="bugtests.dir" value="${basedir}/bugtests" />
        <property name="test.shell.dir" value="${basedir}/tests/shell" />

        <!-- Intermediate products including generated code and compiled classews go here: -->
        <property name="build.dir" value="${basedir}/build" />
        <property name="compile.dir" value="${build.dir}/classes" />
        <property name="test.compile.dir" value="${build.dir}/testclasses" />
        <property name="exposed.dir" value="${build.dir}/exposed" />
        <property name="gensrc.dir" value="${build.dir}/gensrc" />

        <!-- The distribution (mirroring the user's installation) is built here: -->
        <property name="dist.dir" value="${basedir}/dist" />
        <property name="apidoc.dir" value="${dist.dir}/Doc/javadoc" />

        <!-- Test reports. -->
        <property name="reports.dir" value="${basedir}/reports" />
        <property name="junit.dir" value="${reports.dir}/junit" />
        <property name="junit.reports" value="${junit.dir}/raw" />

        <!-- Artefacts for publication. -->
        <property name="pubs.dir" value="${basedir}/publications" />
    </target>

    <target name="common-jars" depends="common-dirs">
        <!-- Names of JARs we (may) produce according to target. -->

        <!-- Target: jar. Just the Jython code: needs main.classpath to work. Material in this JAR
             will be copied to distributable JARs. -->
        <property name="jython.dev.jar" value="jython-dev.jar" />

        <!-- Target: jar-test. Jython test code: needs jython-dev.jar and main.classpath to work.
              Material in this JAR will *not* be copied to distributable JARs.  -->
        <property name="jython.test.jar" value="jython-test.jar" />

        <!-- Target: jar-complete. jython.deploy.jar subsumes jython.dev.jar, and adds shaded
             dependencies. For directory-based installations with a home, library, etc..  -->
        <property name="jython.deploy.jar" value="jython.jar" />

        <!-- Target: jar-standalone. jython.standalone.jar subsumes jython.deploy.jar, and
             adds the Python library as a resource. A self-contained Python in a JAR. -->
        <property name="jython.standalone.jar" value="jython-standalone.jar" />

        <!-- Target: all-jars creates these and all the above JARs.  -->
        <property name="jython.javadoc.jar" value="javadoc.jar" />
        <property name="jython.sources.jar" value="sources.jar" />
    </target>

    <target name="common-paths" depends="common-dirs">

        <!-- ${informix.jar}, if defined, denotes a non-free JAR to be added to the class path. -->
        <condition property="informix.present" else="false">
            <and>
                <isset property="informix.jar"/>
                <available classname="com.informix.jdbc.IfxDriver"
                           classpath="${informix.jar}" />
            </and>
        </condition>

        <!-- ${oracle.jar}, if defined, denotes a non-free JAR to be added to the class path. -->
        <condition property="oracle.present" else="false">
            <and>
                <isset property="oracle.jar"/>
                <available classname="oracle.jdbc.driver.OracleDriver"
                           classpath="${oracle.jar}" />
            </and>
        </condition>

        <!-- classpaths -->

        <local name="informix.location"/>
        <condition property="informix.location" value="${informix.jar}" else="">
            <istrue value="${informix.present}"/>
        </condition>

        <local name="oracle.location"/>
        <condition property="oracle.location" value="${oracle.jar}" else="">
            <istrue value="${oracle.present}"/>
        </condition>

        <path id="main.classpath">
            <!-- The non-free database driver JARs, if not present. -->
            <filelist files="${informix.location} ${oracle.location}" />

            <!-- Further database and Java EE-related JARs -->
            <filelist dir="${extlibs.dir}">
                <file name="servlet-api-2.5.jar" />
                <file name="mysql-connector-java-5.1.42-bin.jar" />
                <file name="postgresql-42.1.1.jre7.jar" />
            </filelist>

            <!-- Other JARs (alphabetical) -->
            <filelist dir="${extlibs.dir}">
                <file name="antlr-complete-3.5.2.jar" /> <!-- ANTLR 3 until we upgrade parsing -->
                <file name="asm-9.3.jar" />
                <file name="asm-commons-9.3.jar" />
                <file name="asm-util-9.3.jar" />
                <file name="commons-compress-1.21.jar"/>
                <file name="failureaccess-1.0.1.jar" />
                <file name="guava-32.1.2-jre.jar" />
                <file name="icu4j-71.1.jar" />
                <file name="jffi-1.3.9.jar"/>
                <file name="java-sizeof-0.0.5.jar"/>
                <file name="jnr-constants-0.10.3.jar"/>
                <file name="jnr-ffi-2.2.12.jar"/>
                <file name="jnr-netdb-1.2.0.jar"/>
                <file name="jnr-posix-3.1.15.jar"/>
                <file name="jline-2.14.5.jar"/>
                <file name="netty-buffer-4.1.73.Final.jar"/>
                <file name="netty-codec-4.1.73.Final.jar"/>
                <file name="netty-common-4.1.73.Final.jar"/>
                <file name="netty-handler-4.1.73.Final.jar"/>
                <file name="netty-resolver-4.1.73.Final.jar"/>
                <file name="netty-transport-4.1.73.Final.jar"/>
            </filelist>
        </path>

        <path id="test.classpath">
            <path refid="main.classpath"/>
            <filelist dir="${extlibs.dir}">
                <!-- Pin to 4.10 until dependency on hamcrest classes resolved. -->
                <file name="junit-4.10.jar" />
            </filelist>
            <pathelement location="${exposed.dir}" />
            <pathelement location="${compile.dir}" />
            <pathelement location="${test.compile.dir}" />
            <pathelement location="${cpptasks.jar.dir}" />
        </path>
    </target>

    <target name="init"
        depends="developer-preinit, common-jars, common-paths, common-version-strings">

        <!-- We can now compose the version as seen in sys.version and the installer -->
        <property name="jython.version" value="${jython.release}${snapshot.suffix}" />

        <!-- Build-time OS detection -->
        <condition property="os.family.unix">
            <os family="unix"/>
        </condition>
        <condition property="os.family.windows">
            <os family="windows"/>
        </condition>

        <!-- Options we use when compiling (if not beaten to it: see *-preinit) -->
        <property name="build.compiler" value="modern" />
        <property name="jdk.target.version" value="${jython.java.version}" />
        <property name="jdk.source.version" value="${jython.java.version}" />
        <property name="deprecation" value="true" />
        <property name="debug" value="true" />
        <property name="nowarn" value="true" />
        <property name="javac.Xlint" value="-Xlint -Xlint:-serial -Xlint:-unchecked -Xlint:-cast"/>

        <!-- Options we use when building JARs (if not beaten to it: see *-preinit) -->
        <property name="jar.update" value="true" />
    </target>

    <target name="developer-preinit">
        <!-- This is invoked by init as its first dependency, which in turn is the first
             dependency of many auxiliary targets. When the official "installer" or "full-build"
             target is called, its specific installer-preinit or full-preinit will usually
             have set the properties dealt with here. When, in the course of development, we
             invoke various "unofficial" targets directly, this target acts as "developer-preinit".
        -->

        <!-- The suffix is "-" and the snapshot name, otherwise this is a developer build. -->
        <condition property="snapshot.suffix" value="-${snapshot.name}" else="-DEV">
            <isset property="snapshot.name"/>
        </condition>
    </target>

    <target name="installer-preinit" depends="common-config">
        <property name="snapshot.name" value="SNAPSHOT"/>
        <property name="jar.update" value="true" />
        <!-- Ensure we regenerate version.properties -->
        <property name="brand-up-to-date" value="false" />
    </target>

    <target name="full-preinit" depends="common-config">
        <!-- What is this? Why here in the full build only? -->
        <property name="cpptasks.jar.dir" value="${basedir}/extlibs/cpptasks/cpptasks.jar" />
        <property name="jar.update" value="false" />
        <property name="brand-up-to-date" value="false" />
    </target>

    <target name="full-check" depends="full-preinit, force-snapshot-if-polluted, init, full-dump"
            description="check the viability of a full build without running it" >
        <!-- Require all of the optional jars for a full build -->
        <fail unless="${informix.present}" message="informix jar not present" />
        <fail unless="${oracle.present}" message="oracle jar not present" />
        <!-- Require all git for a full build -->
        <fail unless="${git.present}" message="A Git repository is required" />
    </target>

    <target name="dump-env" depends="init, dump"
            description="dump the properties computed for a regular build without running it" />

    <target name="dump" >
        <echo>.</echo>
        <echo>Build environment for ${ant.project.name}</echo>
        <echo>(Note: if ${propertyname} is displayed, then the property is not set)</echo>
        <echo>--- build Jython version ---</echo>
        <echo>jython.version.short      = '${jython.version.short}'</echo>
        <echo>jython.release            = '${jython.release}'</echo>
        <echo>jython.version            = '${jython.version}'</echo>
        <echo>snapshot.name             = '${snapshot.name}'</echo>
        <echo>snapshot.suffix           = '${snapshot.suffix}'</echo>
        <echo>jython.dev.jar            = '${jython.dev.jar}'</echo>
        <echo>jython.deploy.jar         = '${jython.deploy.jar}'</echo>
        <echo>jython.standalone.jar     = '${jython.standalone.jar}'</echo>
        <echo>jython.javadoc.jar        = '${jython.javadoc.jar}'</echo>
        <echo>jython.sources.jar        = '${jython.sources.jar}'</echo>
        <echo>jar.update                = '${jar.update}'</echo>
        <echo>--- optional libraries ---</echo>
        <echo>informix                  = '${informix.jar}'</echo>
        <echo>informix.present          = '${informix.present}'</echo>
        <echo>oracle                    = '${oracle.jar}'</echo>
        <echo>oracle.present            = '${oracle.present}'</echo>
        <echo>--- properties ---</echo>
        <echo>basedir                   = '${basedir}'</echo>
        <echo>source.dir                = '${source.dir}'</echo>
        <echo>build.dir                 = '${build.dir}'</echo>
        <echo>compile.dir               = '${compile.dir}'</echo>
        <echo>test.compile.dir          = '${test.compile.dir}'</echo>
        <echo>exposed.dir               = '${exposed.dir}'</echo>
        <echo>gensrc.dir                = '${gensrc.dir}'</echo>
        <echo>dist.dir                  = '${dist.dir}'</echo>
        <echo>apidoc.dir                = '${apidoc.dir}'</echo>
        <echo>templates.dir             = '${templates.dir}'</echo>
        <echo>templates.lazy            = '${templates.lazy}'</echo>
        <echo>python.lib                = '${python.lib}'</echo>
        <echo>--- compiler options ---</echo>
        <echo>build.compiler            = '${build.compiler}'</echo>
        <echo>jdk.target.version        = '${jdk.target.version}'</echo>
        <echo>jdk.source.version        = '${jdk.source.version}'</echo>
        <echo>deprecation               = '${deprecation}'</echo>
        <echo>debug                     = '${debug}'</echo>
        <echo>nowarn                    = '${nowarn}'</echo>
        <echo>main.classpath            = '${ant.refid:main.classpath}'</echo>
        <echo>--- test config ---</echo>
        <echo>test                      = '${test}'</echo>
        <echo>test.source.dir           = '${test.source.dir}'</echo>
        <echo>reports.dir               = '${reports.dir}'</echo>
        <!-- <echo>test.classpath            = '${ant.refid:test.classpath}'</echo> -->
    </target>

    <target name="full-dump"
            depends="git-is-unmodified, git-is-clean, git-is-tagged, git-branch, dump" >
        <echo>--- properties only used for a full-build ---</echo>
        <echo>git.present               = '${git.present}'</echo>
        <echo>build.git.is_unmodified   = '${build.git.is_unmodified}'</echo>
        <echo>build.git.is_clean        = '${build.git.is_clean}'</echo>
        <echo>build.git.is_tagged       = '${build.git.is_tagged}'</echo>
        <echo>build.git.branch          = '${build.git.branch}'</echo>
        <echo>build.git.tag             = '${build.git.tag}'</echo>
        <echo>build.git.version         = '${build.git.version}'</echo>
    </target>

    <!-- Delete all intermediate build products. Directories correspond to those bases defined in
         common-dirs and built upon by the various targets as they are executed.  -->
    <target name="clean" depends="common-dirs, clean-test"
        description="Delete contents of working directories">
        <delete includeemptydirs="true" failonerror="false">
            <!-- the package cache (now it is not in dist.dir). -->
            <fileset dir="${cache.dir}" includes="**/*" erroronmissingdir="false" />
            <!-- all files and subdirectories of ${build.dir}, without ${build.dir} itself. -->
            <fileset dir="${build.dir}" includes="**/*" defaultexcludes="false" />
            <!-- all files and subdirectories of ${dist.dir}, without ${dist.dir} itself. -->
            <fileset dir="${dist.dir}" includes="**/*" defaultexcludes="false" />
            <!-- all files and subdirectories of ${pubs.dir}, without ${pubs.dir} itself. -->
            <fileset dir="${pubs.dir}" includes="**/*" erroronmissingdir="false" />
        </delete>
    </target>

    <target name="devclean" depends="common-dirs, clean-test"
        description="Delete contents of working directories preserving antlr, cachedir, and Lib">
        <delete includeemptydirs="true" failonerror="false">
            <!-- all files and subdirectories of ${build.dir}, without ${build.dir} itself. -->
            <fileset dir="${build.dir}" includes="**/*" excludes="gensrc/**" />
            <!-- all files and subdirectories of ${dist.dir}, without ${dist.dir} itself. -->
            <fileset dir="${dist.dir}" includes="**/*" excludes="Lib/**" />
        </delete>
    </target>

    <target name="force-snapshot-if-polluted" depends="git-is-unmodified, git-is-clean, git-is-tagged">
        <!-- Ensure that a snapshot name is provided, if the workspace is not a pure checkout.
             This only works before init is called, since it will set a value. -->

        <!-- Check for conditions that will force us to a snapshot build. -->
        <local name="diagnosis" />
        <condition property="diagnosis"
                   value="The working directory is not a Git repository">
            <not><istrue value="${git.present}"/></not>
        </condition>
        <condition property="build.git.status"
                   value="The git command failed (or is not on the path).">
            <not><istrue value="${git.present}"/></not>
        </condition>
        <condition property="diagnosis"
                   value="Version-controlled files have been edited since the last commit">
            <not><isset property="build.git.is_unmodified"/></not>
        </condition>
        <condition property="diagnosis"
                   value="Workspace contains uncontrolled files">
            <not><isset property="build.git.is_clean"/></not>
        </condition>
        <condition property="diagnosis"
                   value="Change set ${build.git.version} is not tagged 'v${jython.release}'">
            <not><isset property="build.git.is_tagged"/></not>
        </condition>

        <!-- If there was any kind of defect, make this a snapshot build. -->
        <condition property="snapshot.name" value="SNAPSHOT">
            <isset property="diagnosis"/>
        </condition>

        <!-- Now set the suffix as well, before init gets to try. (Our else is different.) -->
        <condition property="snapshot.suffix" value="-${snapshot.name}" else="">
            <isset property="snapshot.name"/>
        </condition>

        <!-- Produce a message about that. -->
        <local name="message" />
        <condition property="message"
                   value="${diagnosis} - build is a snapshot."
                   else ="Build is for release of ${jython.release}.">
            <isset property="diagnosis"/>
        </condition>
        <echo>
${message}

${build.git.status}
        </echo>

    </target>

    <target name="git-is-unmodified" depends="git-is-tagged" if="${git.present}">
        <!-- If build.git.tag has no -dirty at the end, set build.git.is_unmodified -->
        <condition property="build.git.is_unmodified">
            <and>
                <istrue value="${git.present}" />
                <not><contains string="${build.git.tag}" substring="-dirty" /></not>
            </and>
        </condition>
    </target>

    <target name="git-is-clean" depends="git-present" if="${git.present}">
        <!-- Set build.git.status, and if it lists no files, set build.git.is_clean -->
        <exec executable="git" outputproperty="build.git.status">
            <arg line="status --porcelain" />
        </exec>
        <!-- Check there are no extra files (except as per .gitignore) to catch in the build. -->
        <condition property="build.git.is_clean">
            <and>
                <istrue value="${git.present}" />
                <length string="${build.git.status}" trim="true" length="0" />
            </and>
        </condition>
    </target>

    <target name="git-is-tagged" depends="git-present, common-version-strings" if="${git.present}">
        <!-- Set build.git.tag, and if it matches this version, set build.git.is_tagged -->
        <exec executable="git" outputproperty="build.git.tag">
            <arg line="describe --all --always --dirty"/>
        </exec>
        <!-- Check we are at a tag matching the release claimed in the configuration. -->
        <condition property="build.git.is_tagged">
            <and>
                <istrue value="${git.present}" />
                <equals arg1="${build.git.tag}" arg2="tags/v${jython.release}" />
            </and>
        </condition>
    </target>

    <target name="git-branch" depends="git-present" if="${git.present}">
        <!-- Set build.git.branch. -->
        <exec executable="git" outputproperty="build.git.branch">
            <arg line="name-rev --name-only HEAD"/>
        </exec>
    </target>

    <target name="git-present" depends="common-dirs">
        <!-- Work out whether Git is available: the command and a repo. -->
        <!-- Try using Git to set "build.git.version" as a test of availability,
             as we need it anyway. This will fail if git is not on the path or
             .git doesn't exist. -->
        <local name="git_result" />
        <local name="git_output" />
        <exec executable="git" outputproperty="git_output"
            failifexecutionfails="false" failonerror="false" resultproperty="git_result">
            <arg line="rev-parse --short HEAD"/>
        </exec>
        <!-- Deduce presence of the git command and repo from how that execution went. -->
        <condition property="git.present" else="false">
            <and>
                <isset property="git_output" />
                <equals arg1="${git_result}" arg2="0" />
                <available file="${basedir}/.git" type="dir" />
            </and>
        </condition>
        <!-- And if both are present, the result provides the change set id. -->
        <condition property="build.git.version" value="${git_output}">
            <istrue value="${git.present}" />
        </condition>
    </target>

    <target name="brand-up-to-date" depends="common-paths, git-is-unmodified">
        <!-- Check freshness of generated version.properties file. -->
        <condition property="brand-up-to-date" else="false">
            <!-- The branding (version.properties) is adequately up to date if ... -->
            <and>
                <!-- The file exists (and we can't have edited the version info in build.xml). -->
                <uptodate targetfile="${compile.dir}/org/python/version.properties">
                    <srcfiles file="build.xml" />
                </uptodate>
                <!-- *and* we have uncommited changes. This may sound backwards, but the idea is
                     that part-way through development, we'd rather not wait to regenerate the
                     file (and JAR), only when we reach the little rubicon of a commit. -->
                <not><isset property="build.git.is_unmodified"/></not>
            </and>
        </condition>
    </target>

    <target name="brand-version-metadata"
            depends="git-present, brand-up-to-date"
            unless="${brand-up-to-date}"
            if="${git.present}">
        <!-- Get the git metadata (branch and tag) to update version.properties (see
             brand-version"). We're lazy about this: we only do it if we need the information for
             brand-version. -->
        <exec executable="git" outputproperty="build.git.branch">
            <arg line="name-rev --name-only HEAD"/>
        </exec>
        <exec executable="git" outputproperty="build.git.tag">
            <arg line="describe --all --always --dirty"/>
        </exec>
    </target>

    <target name="brand-version-nogit" depends="git-present" unless="${git.present}">
        <!-- Substitute git metadata (branch and tag) to update version.properties. -->
        <property name="build.git.branch" value="uncontrolled" />
        <property name="build.git.version" value="uncontrolled" />
        <property name="build.git.tag" value="-dirty" />
    </target>

    <target name="brand-version"
            depends="brand-version-metadata, brand-version-nogit, init"
            unless="${brand-up-to-date}">
        <!-- Update version.properties, but only if something significant has changed. -->

        <!-- These values are guaranteed by the dependencies, even if git is not installad or there
             is no repo.-->
        <echo>Writing git and build metadata to version.properties.</echo>
        <echo>jython.version        = ${jython.version}</echo>
        <echo>build.git.branch      = ${build.git.branch}</echo>
        <echo>build.git.version     = ${build.git.version}</echo>
        <echo>build.git.tag         = ${build.git.tag}</echo>

        <tstamp>
            <format property="build.date" pattern="MMM d yyyy" offset="0"/>
            <format property="build.time" pattern="HH:mm:ss" offset="0"/>
        </tstamp>
        <mkdir dir="${compile.dir}/org/python"/>
        <echo file="${compile.dir}/org/python/version.properties"># Jython version information
jython.version=${jython.version}
jython.major_version=${jython.major_version}
jython.minor_version=${jython.minor_version}
jython.micro_version=${jython.micro_version}
jython.release_level=${jython.release_level}
jython.release_serial=${jython.release_serial}
jython.build.date=${build.date}
jython.build.time=${build.time}
jython.build.git_branch=${build.git.branch}
jython.build.git_tag=${build.git.tag}
jython.build.git_version=${build.git.version}</echo>
    </target>

    <target name="brand-readme" depends="init">
        <!-- Copy over README.txt and replace placeholders with information from the build. -->
        <copy file="${basedir}/README.txt" todir="${dist.dir}" overwrite="true" />

        <!-- An article and adjective to precede "release" to appear in README.txt -->
        <local name="readme.release" />
        <condition property="readme.release" value="an alpha">
            <equals arg1="${jython.release_level}" arg2="${PY_RELEASE_LEVEL_ALPHA}" />
        </condition>
        <condition property="readme.release" value="a beta">
            <equals arg1="${jython.release_level}" arg2="${PY_RELEASE_LEVEL_BETA}" />
        </condition>
        <condition property="readme.release" value="a candidate" else="a final">
            <equals arg1="${jython.release_level}" arg2="${PY_RELEASE_LEVEL_GAMMA}" />
        </condition>

        <!-- README.txt contains this paragraph if this is a snapshot build. -->
        <local name="snapshot.banner.active" />
        <property name="snapshot.banner.active">
-------------------------------------------------------------------------
This is a snapshot build. It reflects the current development status.
The text for an official release would continue like ...
-------------------------------------------------------------------------
        </property>

        <!-- Change README.txt to replace placeholders with version-specific information. -->
        <local name="snapshot.banner" />
        <condition property="snapshot.banner" value="" else="${snapshot.banner.active}">
            <equals arg1="${snapshot.suffix}" arg2="" />
        </condition>
        <replace file="${dist.dir}/README.txt" encoding="UTF-8">
            <replacefilter token="@jython.version@" value="${jython.version}" />
            <replacefilter token="@snapshot.banner@" value="${snapshot.banner}" />
            <replacefilter token="@readme.release@" value="${readme.release}" />
            <replacefilter token="@jython.version.short@" value="${jython.version.short}" />
            <replacefilter token="@os.name@" value="${os.name}" />
            <replacefilter token="@java.vendor@" value="${java.vendor}" />
            <replacefilter token="@java.version@" value="${java.version}" />
            <replacefilter token="@jdk.target.version@" value="${jdk.target.version}" />
        </replace>
    </target>

    <target name="template-init" depends="init">
        <javac srcdir="${source.dir}/"
                destdir="${compile.dir}"
                target="${jdk.target.version}"
                source="${jdk.source.version}"
                debug="${debug}"
                deprecation="${deprecation}"
                nowarn="${nowarn}"
                includeantruntime="false">
            <include name="org/python/util/TemplateAntTask.java" />
            <compilerarg line="${javac.Xlint}"/>
        </javac>
    </target>

    <target name="template" depends="template-init">
        <taskdef name="gentempl" classname="org.python.util.TemplateAntTask"
            classpath="${compile.dir}" />
        <gentempl srcdir="${templates.dir}" verbose="true" lazy="${templates.lazy}"/>
    </target>

    <target name="antlr-up-to-date" depends="common-paths">
        <!-- Check freshness of generated parser & lexer files. -->
        <uptodate property="antlr-up-to-date">
            <!-- We don't check freshness of all generated files since they're made in a batch. -->
            <srcfiles dir="${basedir}/grammar" includes="Python*.g" />
            <globmapper from="*.g" to="${gensrc.dir}/org/python/antlr/*Parser.java" />
        </uptodate>
    </target>

    <target name="antlr-gen" depends="common-paths, antlr-up-to-date" unless="antlr-up-to-date">
        <local name="out" />
        <property name="out" value="${gensrc.dir}/org/python/antlr" />
        <mkdir dir="${out}" />
        <java classname="org.antlr.Tool"
              dir="${basedir}"
              failonerror="true"
              fork="true" >
            <jvmarg value="-Xmx512m"/>
            <jvmarg value="-Dfile.encoding=UTF-8"/>
            <arg value="-Xconversiontimeout"/>
            <arg value="2000"/>
            <arg value="-fo"/>
            <arg path="${out}"/>
            <arg value="-lib"/>
            <arg path="${out}"/>
            <arg file="${basedir}/grammar/Python.g"/>
            <arg file="${basedir}/grammar/PythonPartial.g"/>
            <classpath refid="main.classpath"/>
        </java>

        <!-- copy the .tokens to /grammar, for usage in ANTLRWorks -->
        <!--
        <copy todir="grammar" preservelastmodified="true">
            <fileset dir="build/gensrc/org/python/antlr">
                <include name="Python.tokens" />
            </fileset>
        </copy>
        -->
    </target>

    <target name="jarless" depends="compile, pycompile"/>

    <target name="compile" depends="init, antlr-gen, brand-version">
        <mkdir dir="${compile.dir}"/>
        <javac destdir="${compile.dir}"
               target="${jdk.target.version}"
               source="${jdk.source.version}"
               debug="${debug}"
               deprecation="${deprecation}"
               nowarn="${nowarn}"
               includeantruntime="true"
               memoryMaximumSize="1024m"
               fork="true"
               encoding="UTF-8">
            <compilerarg line="${javac.Xlint}"/>
            <src path="${source.dir}"/>
            <src path="${gensrc.dir}"/>
            <exclude name="**/handler/InformixDataHandler.java" unless="${informix.present}" />
            <exclude name="**/handler/OracleDataHandler.java" unless="${oracle.present}" />
            <classpath refid="main.classpath" />
        </javac>

        <javac srcdir="${basedir}/Lib"
               includes="jxxload_help/**"
               destdir="${compile.dir}"
               target="${jdk.target.version}"
               source="${jdk.source.version}"
               debug="${debug}"
               deprecation="${deprecation}"
               nowarn="${nowarn}"
               includeantruntime="false">
            <compilerarg line="${javac.Xlint}"/>
        </javac>

        <copy file="${source.dir}/org/python/modules/ucnhash.dat"
              todir="${compile.dir}/org/python/modules"
              preservelastmodified="true" />

        <copy todir="${compile.dir}" preservelastmodified="true">
            <fileset dir="${source.dir}">
                <include name="**/*.properties" />
            </fileset>
        </copy>

        <!-- grammar must now be up to date -->
        <property name="antlr-up-to-date" value="true" />

        <copy todir="${compile.dir}/META-INF/services">
            <fileset dir="${source.dir}/META-INF/services" />
        </copy>
    </target>

    <target name="compile-test" depends="compile">
        <!-- java files used by tests -->
        <mkdir dir="${test.compile.dir}"/>
        <javac srcdir="${test.source.dir}"
               destdir="${test.compile.dir}"
               target="${jdk.target.version}"
               source="${jdk.source.version}"
               debug="${debug}"
               deprecation="${deprecation}"
               nowarn="${nowarn}"
               includeantruntime="false"
               encoding="UTF-8">
            <compilerarg line="${javac.Xlint}"/>
            <classpath refid="test.classpath" />
        </javac>
    </target>

    <!--
    If you run this before running regrtest, test__rawffi.py should pass.
    So far I have been unable to enable cpptasks without passing an arg to ant.
    To run this task like I am do:

    ant -lib extlibs/cpptasks/cpptasks.jar compile_cpp

    XXX: get cpptasks running without an arg to ant.
    -->
    <target name="compile_cpp" depends="compile">
        <taskdef resource="cpptasks.tasks"/>
        <cc outtype="shared" subsystem="console" outfile="ctypes_test" objdir="${compile.dir}">
             <fileset dir="tests/c" includes="*.c"/>
         </cc>
    </target>

    <target name="expose" depends="compile">
        <taskdef name="expose" classname="org.python.expose.generate.ExposeTask">
            <classpath>
                <path refid="main.classpath" />
                <pathelement path="${compile.dir}" />
            </classpath>
        </taskdef>
        <mkdir dir="${exposed.dir}" />
        <expose srcdir="${compile.dir}"
            destdir="${exposed.dir}"
            includesfile="${basedir}/CoreExposed.includes"/>
    </target>

    <target name="jar-complete" depends="jar, pycompile">
        <taskdef name="jarjar" classname="org.pantsbuild.jarjar.JarJarTask">
            <classpath>
                <pathelement path="extlibs/jarjar-1.7.2.jar" />
                <path refid="main.classpath" />
            </classpath>
        </taskdef>
        <jarjar destfile="${dist.dir}/${jython.deploy.jar}"  update="${jar.update}">
            <zipfileset src="${dist.dir}/${jython.dev.jar}"/>
            <!-- pin to Antlr 3 until we upgrade parsing -->
            <zipfileset src="extlibs/antlr-runtime-3.5.2.jar"/>
            <rule pattern="org.antlr.runtime.**" result="org.python.antlr.runtime.@1"/>
            <zipfileset src="extlibs/asm-9.3.jar" excludes="module-info.class"/>
            <zipfileset src="extlibs/asm-commons-9.3.jar" excludes="module-info.class"/>
            <zipfileset src="extlibs/asm-util-9.3.jar" excludes="module-info.class"/>
            <rule pattern="org.objectweb.asm.**" result="org.python.objectweb.asm.@1"/>
            <zipfileset src="extlibs/bcpkix-jdk18on-1.71.jar" excludes="META-INF/**"/>
            <zipfileset src="extlibs/bcprov-jdk18on-1.71.jar" excludes="META-INF/**"/>
            <rule pattern="org.bouncycastle.**" result="org.python.bouncycastle.@1"/>
            <zipfileset src="extlibs/commons-compress-1.21.jar"/>
            <rule pattern="org.apache.commons.compress.**" result="org.python.apache.commons.compress.@1"/>
            <zipfileset src="extlibs/failureaccess-1.0.1.jar"/>
            <zipfileset src="extlibs/guava-32.1.2-jre.jar"/>
            <rule pattern="com.google.**" result="org.python.google.@1"/>
            <zipfileset src="extlibs/icu4j-71.1.jar"/>
            <rule pattern="com.ibm.icu.**" result="org.python.icu.@1"/>
            <zipfileset src="extlibs/netty-buffer-4.1.73.Final.jar" excludes="META-INF/**"/>
            <rule pattern="io.netty.**" result="org.python.netty.@1"/>
            <zipfileset src="extlibs/netty-codec-4.1.73.Final.jar" excludes="META-INF/**"/>
            <rule pattern="io.netty.**" result="org.python.netty.@1"/>
            <zipfileset src="extlibs/netty-common-4.1.73.Final.jar" excludes="META-INF/**"/>
            <rule pattern="io.netty.**" result="org.python.netty.@1"/>
            <zipfileset src="extlibs/netty-handler-4.1.73.Final.jar" excludes="META-INF/**"/>
            <rule pattern="io.netty.**" result="org.python.netty.@1"/>
            <zipfileset src="extlibs/netty-resolver-4.1.73.Final.jar" excludes="META-INF/**"/>
            <rule pattern="io.netty.**" result="org.python.netty.@1"/>
            <zipfileset src="extlibs/netty-transport-4.1.73.Final.jar" excludes="META-INF/**"/>
            <rule pattern="io.netty.**" result="org.python.netty.@1"/>
            <zipfileset src="${extlibs.dir}/java-sizeof-0.0.5.jar"/>
            <rule pattern="com.carrotsearch.sizeof.**" result="org.python.sizeof.@1"/>
            <!-- these stub jars are pre-built in https://github.com/jnr/jffi/tree/master/archive
                and rarely if ever change -->
            <zipfileset src="extlibs/jffi-aarch64-Linux.jar"/>
            <zipfileset src="extlibs/jffi-arm-Linux.jar"/>
            <zipfileset src="extlibs/jffi-Darwin.jar"/>
            <zipfileset src="extlibs/jffi-i386-FreeBSD.jar"/>
            <zipfileset src="extlibs/jffi-i386-Linux.jar"/>
            <zipfileset src="extlibs/jffi-i386-OpenBSD.jar"/>
            <zipfileset src="extlibs/jffi-i386-SunOS.jar"/>
            <zipfileset src="extlibs/jffi-i386-Windows.jar"/>
            <zipfileset src="extlibs/jffi-ppc64le-Linux.jar"/>
            <zipfileset src="extlibs/jffi-ppc-AIX.jar"/>
            <zipfileset src="extlibs/jffi-ppc-Linux.jar"/>
            <zipfileset src="extlibs/jffi-ppc64-Linux.jar"/>
            <zipfileset src="extlibs/jffi-s390x-Linux.jar"/>
            <zipfileset src="extlibs/jffi-sparc-SunOS.jar"/>
            <zipfileset src="extlibs/jffi-sparcv9-SunOS.jar"/>
            <zipfileset src="extlibs/jffi-x86_64-FreeBSD.jar"/>
            <zipfileset src="extlibs/jffi-x86_64-Linux.jar"/>
            <zipfileset src="extlibs/jffi-x86_64-OpenBSD.jar"/>
            <zipfileset src="extlibs/jffi-x86_64-SunOS.jar"/>
            <zipfileset src="extlibs/jffi-x86_64-Windows.jar"/>
            <!-- remainder of JNR, JFFI -->
            <zipfileset src="extlibs/jffi-1.3.9.jar"/>
            <zipfileset src="${extlibs.dir}/jnr-constants-0.10.3.jar"/>
            <zipfileset src="${extlibs.dir}/jnr-ffi-2.2.12.jar"/>
            <zipfileset src="${extlibs.dir}/jnr-netdb-1.2.0.jar"/>
            <zipfileset src="${extlibs.dir}/jnr-posix-3.1.15.jar"/>
            <zipfileset src="extlibs/xercesImpl-2.12.2.jar" excludes="META-INF/services/*"/>
            <rule pattern="org.apache.xml.**" result="org.python.apache.xml.@1"/>
            <rule pattern="org.apache.xerces.**" result="org.python.apache.xerces.@1"/>
            <rule pattern="org.apache.wml.**" result="org.python.apache.wml.@1"/>
            <rule pattern="org.apache.html.**" result="org.python.apache.html.@1"/>
            <zipfileset src="extlibs/jline-2.14.5.jar"/>
            <rule pattern="jline.**" result="org.python.jline.@1"/>
            <manifest>
                <attribute name="Main-Class" value="org.python.util.jython" />
                <attribute name="Built-By" value="${user.name}" />
                <attribute name="Implementation-Vendor" value="Python Software Foundation"/>
                <attribute name="Implementation-Title" value="Jython fat jar"/>
                <attribute name="Implementation-Version" value="${jython.version}"/>
                <!-- info section. ATTN: no blanks, no '.' in the names -->
                <section name="Build-Info">
                    <attribute name="version" value="${jython.version}" />
                    <attribute name="oracle" value="${oracle.present}" />
                    <attribute name="informix" value="${informix.present}" />
                    <attribute name="build-compiler" value="${build.compiler}" />
                    <attribute name="jdk-target-version" value="${jdk.target.version}" />
                    <attribute name="debug" value="${debug}" />
                </section>
            </manifest>
        </jarjar>
    </target>

    <target name="jar-standalone" depends="jar-complete, copy-lib">
        <jar destfile="${dist.dir}/${jython.standalone.jar}" update="${jar.update}">
            <zipfileset src="${dist.dir}/${jython.deploy.jar}"/>
            <fileset dir="${dist.dir}" includes="Lib/**" excludes="Lib/test/**" />
            <manifest>
                <attribute name="Main-Class" value="org.python.util.jython" />
                <attribute name="Built-By" value="${user.name}" />
                <attribute name="Implementation-Vendor" value="Python Software Foundation"/>
                <attribute name="Implementation-Title" value="Jython fat jar with stdlib"/>
                <attribute name="Implementation-Version" value="${jython.version}"/>
                <!-- info section. ATTN: no blanks, no '.' in the names -->
                <section name="Build-Info">
                    <attribute name="version" value="${jython.version}" />
                    <attribute name="git-build" value="${git.present}" />
                    <attribute name="oracle" value="${oracle.present}" />
                    <attribute name="informix" value="${informix.present}" />
                    <attribute name="build-compiler" value="${build.compiler}" />
                    <attribute name="jdk-target-version" value="${jdk.target.version}" />
                    <attribute name="debug" value="${debug}" />
                </section>
            </manifest>
            <!-- FIXME: Because the standalone JAR may be distributed separately from the
                 installer JAR, it ought really to include necessary licences (Apache, etc.),
                 at least by reference.
            -->
        </jar>
    </target>

    <target name="jar" depends="compile, expose"
            description="build the jython-dev.jar (requiring main classpath and Lib to use).">

        <typedef name="nameunion" classname="org.python.util.NameUnionAntType">
            <classpath>
                <path refid="main.classpath" />
                <pathelement path="${compile.dir}" />
            </classpath>
        </typedef>

        <jar destfile="${dist.dir}/${jython.dev.jar}" duplicate="fail" update="${jar.update}">
            <!-- If only nameunion is used, ant issues a spurious warning about no files being
                 included.  Use a fileset for version.properties just to shut that up. -->
            <fileset dir="${compile.dir}" includes="org/python/version.properties"/>
            <nameunion>
                <fileset dir="${exposed.dir}"/>
                <fileset dir="${compile.dir}"
                    excludes="org/python/expose/generate/**,org/python/version.properties"/>
            </nameunion>
            <manifest>
                <attribute name="Main-Class" value="org.python.util.jython" />
                <attribute name="Built-By" value="${user.name}" />
                <attribute name="Implementation-Vendor" value="Python Software Foundation"/>
                <attribute name="Implementation-Title" value="Jython"/>
                <attribute name="Implementation-Version" value="${jython.version}"/>
                <!-- info section. ATTN: no blanks, no '.' in the names -->
                <section name="Build-Info">
                    <attribute name="version" value="${jython.version}" />
                    <attribute name="git-build" value="${git.present}" />
                    <attribute name="oracle" value="${oracle.present}" />
                    <attribute name="informix" value="${informix.present}" />
                    <attribute name="build-compiler" value="${build.compiler}" />
                    <attribute name="jdk-target-version" value="${jdk.target.version}" />
                    <attribute name="debug" value="${debug}" />
                </section>
            </manifest>
        </jar>
    </target>

    <target name="jar-test" depends="compile-test"
            description="build the jython-test.jar supplementary to jython-dev (and 'callbacker'.">

        <jar destfile="${dist.dir}/callbacker_test.jar" update="${jar.update}">
            <fileset dir="${test.compile.dir}" includes="org/python/tests/Callbacker*"/>
        </jar>

        <jar destfile="${dist.dir}/${jython.test.jar}" duplicate="fail" update="${jar.update}">
            <fileset dir="${test.compile.dir}" />
            <manifest>
                <attribute name="Main-Class" value="org.python.util.jython" />
                <attribute name="Built-By" value="${user.name}" />
                <attribute name="Implementation-Vendor" value="Python Software Foundation"/>
                <attribute name="Implementation-Title" value="Jython Test JAR"/>
                <attribute name="Implementation-Version" value="${jython.version}"/>
                <!-- info section. ATTN: no blanks, no '.' in the names -->
                <section name="Build-Info">
                    <attribute name="version" value="${jython.version}" />
                    <attribute name="git-build" value="${git.present}" />
                    <attribute name="oracle" value="${oracle.present}" />
                    <attribute name="informix" value="${informix.present}" />
                    <attribute name="build-compiler" value="${build.compiler}" />
                    <attribute name="jdk-target-version" value="${jdk.target.version}" />
                    <attribute name="debug" value="${debug}" />
                </section>
            </manifest>
        </jar>
    </target>

    <target name="javadoc" depends="compile">
        <path id="javadoc.classpath">
            <pathelement path="${java.class.path}" />
            <pathelement path="${compile.dir}" />
            <path refid="main.classpath" />
        </path>
        <mkdir dir="${apidoc.dir}" />
        <javadoc sourcepath="${source.dir}"
                 destdir="${apidoc.dir}"
                 source="${jdk.source.version}"
                 encoding="UTF-8"
                 maxmemory="1024m"
                 public="true"
                 breakiterator="yes"
                 packagenames="org.python.core.*, org.python.util.*, org.python.modules.*, com.ziclix.python.sql, com.xhaus.modjy"
                 windowtitle="Jython API documentation"
                 bottom="&lt;a href='http://www.jython.org' target='_top'>Jython homepage&lt;/a>"
        >
            <link href="http://docs.oracle.com/javase/7/docs/api/" />
            <classpath refid="javadoc.classpath" />
        </javadoc>
    </target>

    <target name="all-jars"
            depends="jar-standalone, jar-javadoc, jar-sources"
            description="Build all the JARs (except the installer JAR)." />

    <target name="jar-javadoc" depends="javadoc">
        <jar destfile="dist/${jython.javadoc.jar}" update="${jar.update}">
            <fileset dir="${apidoc.dir}" includes="**"/>
        </jar>
    </target>

    <target name="jar-sources" depends="init">
        <jar destfile="dist/${jython.sources.jar}" update="${jar.update}">
            <fileset dir="${basedir}">
                <exclude name="build/**" />
                <exclude name="dist/**" />
                <exclude name="extlibs/**" />
                <exclude name="Doc/**" />
            </fileset>
        </jar>
    </target>

    <target name="copy-misc-files" depends="init">
        <echo>copy misc files from ${basedir}</echo>
        <copy todir="${dist.dir}" preservelastmodified="true" overwrite="true">
            <fileset dir="${basedir}">
                <include name="ACKNOWLEDGMENTS" />
                <include name="build.xml" />
                <include name="NEWS" />
                <include name="LICENSE.txt" />
                <include name="registry" />
            </fileset>
        </copy>
    </target>

    <target name="copy-full" depends="copy-bin, copy-lib, brand-readme, copy-misc-files">
        <!-- sources: todir has to correspond with installer/**/JarInstaller.java -->
        <echo>copy sources from ${basedir}</echo>
        <copy todir="${dist.dir}" preservelastmodified="true">
            <fileset dir="${basedir}">
                <include name="src/**/*.java" />
                <include name="src/com/**/*.properties" />
                <include name="src/shell/*" />
                <include name="src/templates/*" />
                <include name="Lib/jxxload_help/*.java" />
                <include name="src/org/**/ucnhash.dat" />
                <include name="grammar/*.g" />
                <include name="tests/java/**/*.java" />
                <include name="CoreExposed.includes" />
                <include name="extlibs/**/*.jar" />
                <!-- don't distribute jdbc jars -->
                <exclude name="extlibs/mysql-connector-java-*.jar" />
                <exclude name="extlibs/postgresql-*.jar" />
                <exclude name="extlibs/ifxjdbc.jar" />
                <exclude name="extlibs/ojdbc*.jar" />
                <!-- don't distribute this material either -->
                <exclude name="extlibs/mockrunner*/**" />
                <exclude name="extlibs/cpptasks/**" />
            </fileset>
        </copy>

        <echo>copy the demo files from ${basedir}/Demo</echo>
        <copy todir="${dist.dir}/Demo" preservelastmodified="true">
            <fileset dir="${basedir}/Demo">
              <include name="**/*.java" />
              <include name="**/*.html" />
              <include name="**/*.py" />
              <include name="**/*.txt" />
              <include name="**/*.xml**" />
              <include name="**/jreload/example.jar" />
              <include name="**/jreload/_xample/Version.class" />
              <exclude name="**/jpywork/**" />
            </fileset>
        </copy>
    </target>

    <!-- The copy needed to support developer-build differs from the one when making an installer.
         In this case we must copy all the JARs to javalib and do not copy miscellaneous files.
         Loke lecences and the README. -->
    <target name="copy-dev" depends="copy-javalib, copy-bin, copy-lib" />

    <target name="pycompile" depends="jar, copy-lib">
        <taskdef name="jycompile" classname="org.python.util.JycompileAntTask">
            <classpath path="${dist.dir}/Lib"/>
            <classpath path="${dist.dir}/${jython.dev.jar}" />
            <classpath refid="main.classpath" />
        </taskdef>
        <!-- One might think that the exclusion of lib2to3/tests/** is
             recursive, but one would be wrong ;) It's actually only
             two levels, so for now the workaround is to also include
             data/myfixes/**

             This exclusion for lib2to3/tests/ in general is necessary
             because data/infinite_recursion.py is not compileable by
             Jython - it's too large and will exceed Java method
             limits for the top level script; nor is
             data/py3_test_grammar.py - it's Python 3. Meanwhile
             refactor.get_all_fix_names depends on having *.py, not
             exclusively $py.class, files available in
             lib2to3/tests/data/myfixes/**. -->
        <jycompile srcdir="${dist.dir}/Lib" destdir="${dist.dir}/Lib"
                   excludes="test/**,lib2to3/tests/**,lib2to3/tests/data/myfixes/**"/>
    </target>

    <target name="copy-lib" depends="common-dirs, copy-cpythonlib">
        <copy todir="${dist.dir}/Lib">
            <fileset dir="${basedir}/Lib">
                <exclude name="**/*.class"/>
            </fileset>
        </copy>
    </target>

    <target name="copy-bin" depends="common-dirs">
        <!-- copy the shell scripts and make them executable -->
        <copy todir="${dist.dir}/bin">
            <fileset dir="${source.dir}/shell"/>
        </copy>
        <chmod perm="ugo+rx">
            <fileset dir="${dist.dir}/bin" />
        </chmod>

        <!-- copy the registry -->
        <copy todir="${dist.dir}" file="${basedir}/registry" preservelastmodified="true"/>
    </target>

    <target name="copy-cpythonlib" depends="init">
        <copy file="${basedir}/lib-python/LICENSE.txt"
              tofile="${dist.dir}/LICENSE_CPython.txt"
              preservelastmodified="true" />
        <copy todir="${dist.dir}/Lib">
            <fileset dir="${python.lib}" excludes="**/*.pyc, **/*.pyo" includesfile="${basedir}/CPythonLib.includes">
                <!-- The include file gets all of lib-python/2.7's test directory, but we only want the ones from Jython's Lib.   -->
                <present present="srconly" targetdir="${basedir}/Lib"/>
            </fileset>
        </copy>
    </target>

    <target name="copy-javalib" depends="common-dirs">
        <!-- If this is *not* a full build (so we're doing dev & test) copy $extlibs/* to
             $dist.dir/javalib/*, to be available when using jython-dev.jar
        -->
        <copy todir="${dist.dir}/javalib">
            <fileset dir="${basedir}/extlibs">
                <exclude name="profile.properties"/>
            </fileset>
            <fileset dir="${build.dir}">
                <include name="*.jar"/>
                <include name="*.properties"/>
            </fileset>
        </copy>
    </target>

    <!-- Compile the installer and wrap the build into it. Some contents are required through
         dependencies named, while others (source, javadoc) depend on the history so far. -->
    <target name="jar-installer"
        depends="jar-standalone, copy-full" >

        <echo>compiling installer from ${installer.src.dir}</echo>
        <javac srcdir="${installer.src.dir}"
               includes="org/**"
               destdir="${compile.dir}"
               target="${jdk.target.version}"
               source="${jdk.source.version}"
               debug="${debug}"
               deprecation="${deprecation}"
               nowarn="${nowarn}"
               includeantruntime="false" />

        <echo>copy installer classes to ${dist.dir}</echo>
        <copy todir="${dist.dir}" preservelastmodified="true">
            <fileset dir="${compile.dir}">
                <include name="org/python/util/install/**/*.class" />
                <include name="org/apache/commons/cli/*.class" />
            </fileset>
        </copy>
        <copy file="${installer.src.dir}/org/apache/LICENSE.txt"
            tofile="${dist.dir}/LICENSE_Apache.txt" preservelastmodified="true" />

        <echo>copy installer icon to ${dist.dir}</echo>
        <copy todir="${dist.dir}" preservelastmodified="true">
            <fileset dir="${installer.src.dir}">
                <include name="**/*.png" />
                <include name="**/*.template" />
                <!-- check no /bin directory -->
                <exclude name="bin/**" />
            </fileset>
        </copy>

        <echo>building installer .jar file</echo>
        <jar destfile="${dist.dir}/jython-installer.jar" update="${jar.update}" roundup="false">
            <fileset dir="${dist.dir}">
                <exclude name="jython-installer.jar"/>
                <exclude name="${jython.dev.jar}"/>
                <exclude name="${jython.standalone.jar}"/>
                <exclude name="${jython.javadoc.jar}"/>
                <exclude name="${jython.sources.jar}"/>
                <exclude name="callbacker_test.jar"/>
                <exclude name="extlibs/antlr*.jar" />
                <exclude name="extlibs/asm*.jar" />
                <exclude name="extlibs/jarjar*.jar" />
                <exclude name="extlibs/junit*.jar" />
                <exclude name="extlibs/servlet-api*.jar" />
                <exclude name="extlibs/stringtemplate*.jar" />
                <exclude name="extlibs/xerces*.jar" />
            </fileset>
            <manifest>
                <attribute name="Main-Class" value="org.python.util.install.Installation" />
                <attribute name="Built-By" value="${user.name}" />
                <attribute name="Implementation-Vendor" value="Python Software Foundation"/>
                <attribute name="Implementation-Title" value="Jython installer"/>
                <attribute name="Implementation-Version" value="${jython.version}"/>
                <!-- section for the installer program -->
                <section name="Jython">
                    <attribute name="version" value="${jython.version}" />
                    <attribute name="exclude-dirs" value="org;META-INF" />
                </section>
                <!-- info section. ATTN: no blanks, no '.' in the names -->
                <section name="Build-Info">
                    <attribute name="git-build" value="${git.present}" />
                    <attribute name="oracle" value="${oracle.present}" />
                    <attribute name="informix" value="${informix.present}" />
                    <attribute name="build-compiler" value="${build.compiler}" />
                    <attribute name="jdk-target-version" value="${jdk.target.version}" />
                    <attribute name="debug" value="${debug}" />
                </section>
            </manifest>
        </jar>
    </target>

    <target name="test" depends="clean-test, javatest, launchertest, regrtest, modjytest"
        description="run all the tests"/>

    <target name="singlejavatest" depends="compile-test, expose"
        description="run a single JUnit test (specify with -Dtest=classname)">
        <junit haltonfailure="true" fork="true">
            <formatter type="brief" usefile="false"/>
            <sysproperty key="python.cachedir.skip" value="true"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <classpath refid="test.classpath"/>
            <batchtest skipNonTests="true">
                <fileset dir="${test.source.dir}" includes="**/${test}.java"/>
            </batchtest>
        </junit>
    </target>

    <target name="clean-test" depends="common-dirs"
            description="clean up old test output">
        <delete includeemptydirs="true" failonerror="false">
            <!-- all files and subdirectories of ${reports.dir}, without ${reports.dir} itself. -->
            <fileset dir="${reports.dir}" includes="**/*" />
            <!-- Test droppings (annoying between regrtest and full-build) -->
            <filelist dir="${basedir}">
                <file name="$test_1_tmp" />
                <file name="bar$py.class" />
                <file name="longlist$py.class" />
            </filelist>
        </delete>
    </target>

    <target name="javatest" depends="javatest-basepath, javatest-import"
            description="run all the JUnit tests">
    </target>

    <target name="javatest-basepath" depends="developer-build">
        <mkdir dir="${junit.reports}"/>
        <junit haltonfailure="true" fork="true" printsummary="true">
            <formatter type="xml"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <batchtest todir="${junit.reports}" skipNonTests="true">
                <fileset dir="${test.source.dir}" includes="**/*Test*.java">
                    <exclude name="**/InterpTestCase.java" />
                    <exclude name="**/jythonTest*" /> <!-- Must run interactively -->
                    <exclude name="org/python/antlr/**" />
                    <exclude name="org/python/tests/imp/**" /> <!-- See javatest-import -->
                    <exclude name=".classpath" />
                    <exclude name=".project" />
                </fileset>
            </batchtest>
        </junit>
    </target>

    <target name="javatest-import" depends="developer-build"
            description="run all the JUnit tests that need tests/python in the path.">
        <mkdir dir="${junit.reports}"/>
        <junit haltonfailure="true" fork="true" printsummary="true">
            <formatter type="xml"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <classpath>
                <pathelement location="${basedir}/tests/python"/>
            </classpath>
            <batchtest todir="${junit.reports}">
                <fileset dir="${test.source.dir}" includes="org/python/tests/imp/*Test*.java">
                </fileset>
            </batchtest>
        </junit>
    </target>

    <target name="javatest-ci" depends="developer-build">
        <junit haltonfailure="true" fork="true">
            <formatter type="brief" usefile="false"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <batchtest skipNonTests="true">
                <fileset dir="${test.source.dir}" includes="**/*Test*.java">
                    <exclude name="**/InterpTestCase.java" />
                    <exclude name="**/jythonTest*" /> <!-- Must run interactively -->
                    <exclude name="org/python/antlr/**" />
                    <exclude name="org/python/tests/imp/**" /> <!-- See javatest-import -->
                    <exclude name=".classpath" />
                    <exclude name=".project" />
                </fileset>
            </batchtest>
        </junit>
    </target>

    <target name="idxtest" depends="developer-build">
        <mkdir dir="${junit.reports}"/>
        <junit fork="true" printsummary="true" showoutput="true">
            <formatter type="xml"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <batchtest todir="${junit.reports}">
                <fileset dir="${test.source.dir}" includes="**/*Test*.java">
                    <exclude name="javatests/**/*" />
                    <exclude name="**/InterpTestCase.java" />
                    <exclude name="org/python/antlr/**" />
                    <exclude name="org/python/core/**" />
                    <exclude name="org/python/expose/**" />
                    <exclude name="org/python/jsr223/**" />
                    <exclude name="org/python/tests/**" />
                    <exclude name="org/python/util/**" />
                </fileset>
            </batchtest>
        </junit>
    </target>

    <!-- XXX: how do I share common stuff with "idxtest" target? -->
    <target name="idxtest-debug" depends="developer-build">
        <mkdir dir="${junit.reports}"/>
        <junit fork="true" printsummary="true">
            <formatter type="xml"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <jvmarg value="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5000"/>
            <batchtest todir="${junit.reports}">
                <fileset dir="${test.source.dir}" includes="**/*Test*.java">
                    <exclude name="javatests/**/*" />
                    <exclude name="**/InterpTestCase.java" />
                    <exclude name="org/python/antlr/**" />
                    <exclude name="org/python/core/**" />
                    <exclude name="org/python/expose/**" />
                    <exclude name="org/python/jsr223/**" />
                    <exclude name="org/python/tests/**" />
                    <exclude name="org/python/util/**" />
                </fileset>
            </batchtest>
        </junit>
    </target>

    <target name="modjytest" depends="developer-build">
        <ant dir="tests/modjy">
            <property name="jython_home" value="${dist.dir}"/>
            <property name="mockrunner_home" value="${extlibs.dir}/mockrunner-0.4.1"/>
        </ant>
    </target>

    <target name="launchertest" depends="developer-build" if="os.family.unix">
      <exec executable="${test.shell.dir}/test-jython.sh">
        <arg value="${dist.dir}"/>
      </exec>
    </target>

    <target name="versions" depends="init, versions-unix, versions-windows"
        description="identify the versions of Jython and its platform (needs developer-build)"/>

    <target name="versions-unix" if="os.family.unix">
        <exec executable="${dist.dir}/bin/jython">
            <env key="JAVA_OPTS" value="-Duser.language=en -Duser.region=US"/>
            <arg value="-c"/>
            <arg value="import sys, platform; print sys.version; print platform.java_ver()"/>
        </exec>
    </target>

    <target name="versions-windows" if="os.family.windows">
        <mkdir dir="${junit.reports}"/>
        <exec executable="${dist.dir}/bin/jython.exe">
            <arg value="-c"/>
            <arg value="import sys, platform; print sys.version; print platform.java_ver()"/>
        </exec>
    </target>

    <target name="regrtest" depends="developer-build, regrtest-unix, regrtest-windows"
        description="run Python tests expected to work on Jython"/>

    <target name="regrtest-unix" if="os.family.unix">
        <mkdir dir="${junit.reports}"/>
        <exec executable="${dist.dir}/bin/jython">
            <env key="JAVA_OPTS" value="-Duser.language=en -Duser.region=US"/>
            <arg value="${dist.dir}/Lib/test/regrtest.py"/>
            <!-- Only run the tests that are expected to work on Jython -->
            <arg value="--expected"/>
            <arg value="-j"/>
            <arg value="${junit.reports}"/>
            <arg value="--use"/>
            <arg value="network,subprocess"/>
        </exec>
    </target>

    <target name="regrtest-windows" if="os.family.windows">
        <mkdir dir="${junit.reports}"/>
        <exec executable="${dist.dir}/bin/jython.exe">
            <arg value="${dist.dir}/Lib/test/regrtest.py"/>
            <!-- Only run the tests that are expected to work on Jython -->
            <arg value="--expected"/>
            <arg value="-j"/>
            <arg value="${junit.reports}"/>
            <arg value="--use"/>
            <arg value="network,subprocess"/>
        </exec>
    </target>

    <target name="regrtest-file"
        depends="developer-build, regrtest-unix-file, regrtest-windows-file"
        description="run Python tests specified in file regr.tests"/>

    <target name="regrtest-unix-file" if="os.family.unix">
        <mkdir dir="${junit.reports}"/>
        <exec executable="${dist.dir}/bin/jython">
            <env key="JAVA_OPTS" value="-Duser.language=en -Duser.region=US"/>
            <arg value="${dist.dir}/Lib/test/regrtest.py"/>
            <arg value="--junit-xml"/>
            <arg value="${junit.reports}"/>
            <!-- <arg value="-v"/> -->
            <arg value="--use"/>
            <arg value="network,subprocess"/>
            <!-- Only run the tests specified in the named file -->
            <arg value="--fromfile"/>
            <arg value="${basedir}/regr.tests"/>
        </exec>
    </target>

    <target name="regrtest-windows-file" if="os.family.windows">
        <mkdir dir="${junit.reports}"/>
        <exec executable="${dist.dir}/bin/jython.exe">
            <arg value="${dist.dir}/Lib/test/regrtest.py"/>
            <arg value="--junit-xml"/>
            <arg value="${junit.reports}"/>
            <!-- <arg value="-v"/> -->
            <arg value="--use"/>
            <arg value="network,subprocess"/>
            <!-- Only run the tests specified in the named file -->
            <arg value="--fromfile"/>
            <arg value="${basedir}/regr.tests"/>
        </exec>
    </target>

    <target name="regrtest-ci"
            depends="developer-build, regrtest-unix-ci, regrtest-windows-ci"
            description="run Python tests expected to work on Jython for CI"/>

    <target name="regrtest-unix-ci" if="os.family.unix">
        <mkdir dir="${junit.reports}"/>
        <exec executable="${dist.dir}/bin/jython" failonerror="true">
            <env key="JAVA_OPTS" value="-Duser.language=en -Duser.region=US"/>
            <arg value="${dist.dir}/Lib/test/regrtest.py"/>
            <arg value="-w"/> <!-- re-run failed tests in verbose mode -->
            <!-- Only run the tests that are expected to work on Jython -->
            <arg value="--expected"/>
            <arg value="--use"/>
            <arg value="network,subprocess"/>
            <!-- Exclude particular tests troublesome on the build bots -->
            <arg value="--exclude"/>
            <arg value="test_gc"/> <!-- intermittently fails/hangs (xenial) -->
            <arg value="test_mailbox"/>
            <arg value="test_py_compile"/> <!-- test_relative_path (on osx) -->
            <arg value="test_select_new"/>
            <arg value="test_smtpnet"/>
        </exec>
    </target>

    <target name="regrtest-windows-ci" if="os.family.windows">
        <mkdir dir="${junit.reports}"/>
        <exec executable="${dist.dir}/bin/jython.exe" failonerror="true">
            <env key="JAVA_OPTS" value="-Duser.language=en -Duser.region=US"/>
            <arg value="${dist.dir}/Lib/test/regrtest.py"/>
            <arg value="-w"/> <!-- re-run failed tests in verbose mode -->
            <!-- Only run the tests that are expected to work on Jython -->
            <arg value="--expected"/>
            <arg value="--use"/>
            <arg value="network,subprocess"/>
            <!-- Exclude particular tests troublesome on the build bots -->
            <arg value="--exclude"/>
            <arg value="test_jython_launcher"/> <!-- (on git bash) -->
            <arg value="test_mailbox"/>
            <arg value="test_os_jy"/> <!-- locale command (on git bash) -->
            <arg value="test_select_new"/>
            <arg value="test_smtpnet"/>
        </exec>
    </target>

    <target name="regrtest-html-report" depends="init"
            description="generates HTML report from JUnit XML output of regrtest">
        <mkdir dir="${junit.dir}/html"/>
        <junitreport todir="${junit.dir}">
            <fileset dir="${junit.reports}">
                <include name="TEST-*.xml"/>
            </fileset>
            <report format="frames" todir="${junit.dir}/html" />
        </junitreport>
    </target>

    <!-- run bugtests, create a config if necessary -->
    <target name="bugtest" depends="create-bugtest-config">
        <java classname="org.python.util.jython" fork="true" dir="${bugtests.dir}">
            <classpath>
                <pathelement location="${dist.dir}/${jython.dev.jar}"/>
                <fileset dir="${dist.dir}/javalib"/>
            </classpath>
            <jvmarg value="-Dpython.home=${dist.dir}"/>
            <arg value="driver.py"/>
            <!-- uncomment if you want to run only one test: -->
            <!--
            <arg value="386"/>
            -->
        </java>
    </target>

    <!-- create support_config.py in the bugtset directory only if it doesn't already exist -->
    <target name="create-bugtest-config" depends="init, check-bugtest-config"
        unless="have_bugtest_config">
        <!-- doesn't seem to be a direct way to get at the path to javac,
        java.home points to the jre folder. The following assumes a standard
        jdk layout. Alternative is to try something like:

            <property environment="env"/>
            <property name="jdk.home" value="${env.JAVA_HOME}" />

        or set jdk.home explicitly
        -->
        <path id="bugtest.classpath">
            <pathelement location="${dist.dir}/${jython.dev.jar}" />
            <pathelement location="${dist.dir}/javalib/*" />
            <pathelement location="classes" />
        </path>
        <echo>creating ${bugtests.dir}/support_config.py</echo>
        <property name="jdk.home" value="${java.home}/.." />
        <echo file="${bugtests.dir}/support_config.py">
# this configuration was auto-generated by ant build script,
# safe to edit by hand (won't be overwritten)
java_home="${jdk.home}"
jython_home="${dist.dir}"
classpath="${ant.refid:bugtest.classpath}"
        </echo>
    </target>

    <!-- set property have_bugtest_config if support_config.py already exists in the bugtest directory -->
    <target name="check-bugtest-config">
        <available property="have_bugtest_config" file="${bugtests.dir}/support_config.py"/>
    </target>

</project>
