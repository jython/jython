package org.python.core;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.invoke.WrongMethodTypeException;
import java.util.List;

import org.python.base.InterpreterError;
import org.python.base.MethodKind;
import org.python.core.ArgumentError.Mode;
import org.python.core.PyType.Flag;
import org.python.core.Slot.EmptyException;

/**
 * Descriptor for a method defined in Java, that is to be called
 * from Python. A {@code PyMethodDescr} is a callable object itself,
 * and provides binding behaviour through
 * {@link #__get__(Object, PyType) __get__}, which usually creates a
 * {@link PyJavaFunction}.
 * <p>
 * It suits us to sub-class {@code PyMethodDescr} to express the
 * multiplicity of implementations and to respond to the signature
 * of the method, optimising its data flow to arguments. Instances
 * are therefore obtained by calling
 * {@link PyMethodDescr#fromParser(PyType, ArgParser, List)
 * fromParser}.
 */
abstract class PyMethodDescr extends MethodDescriptor {

    static final PyType TYPE = PyType.fromSpec( //
            new PyType.Spec("method_descriptor", MethodHandles.lookup()) //
                    .flagNot(Flag.BASETYPE) //
                    .flag(Flag.IS_METHOD_DESCR, Flag.IS_DESCR));

    /*
     * We depart from CPython in reifying information from the Java
     * declaration and associated annotations, not as a separate
     * PyMethodDef but in the PyMethodDescr itself and in an attached
     * argument parser. In CPython, the same information is present at
     * run-time in the structure of the code itself, generated by
     * Argument Clinic, in the flags of the PyMethodDef, and as text in
     * the signature that begins the documentation string.
     */

    /**
     * An argument parser supplied to this {@code PyMethodDescr} at
     * construction, from Java reflection of the implementation and from
     * annotations on it. Full information on the signature is available
     * from this structure, and it is available to parse the arguments
     * to {@link #__call__(Object[], String[])} for methods with a
     * complex signature. (In sub-classes that represent methods with a
     * simple signature, it is only used to generate error messages once
     * validity checks fail.)
     */
    final ArgParser argParser;

    /**
     * A handle to the implementation of the function or method. In the
     * general case, this handle has signature {@code (O,O[])O}, and
     * expects a "self" object and an array of arguments, but not in
     * optimised cases.
     * <p>
     * Sub-classes where {@code objclass} has multiple accepted
     * implementations, supersede {@code method} with an array, and
     * place here only a default that throws {@link EmptyException}.
     */
    // CPython PyMethodDef::ml_meth
    final MethodHandle method;

    /**
     * Deduced method signature (useful to have cached when constructing
     * a {@link PyJavaFunction}). Note that this is allowed to differ
     * from {@link MethodSignature#fromParser(ArgParser)
     * MethodSignature.fromParser(argParser)}.
     */
    final MethodSignature signature;

    /**
     * Construct a Python {@code method} descriptor, identifying the
     * implementation by a parser and a method handle.
     *
     * @param objclass the class declaring the method
     * @param argParser describing the signature of the method
     * @param signature to which to coerce the handle
     * @param method handle to invoke the wrapped method or {@code null}
     *     signifying a matching empty handle.
     */
    // Compare CPython PyDescr_NewMethod in descrobject.c
    protected PyMethodDescr(PyType objclass, ArgParser argParser, MethodSignature signature,
            MethodHandle method) {
        super(TYPE, objclass, argParser.name);
        this.argParser = argParser;
        this.signature = signature;
        // Types with multiple impl set method to null -> empty
        assert method == null || objclass.acceptedCount == 1;
        this.method = method == null ? signature.empty : signature.prepare(argParser, method);
    }

    /**
     * Construct a Python {@code method} descriptor from an
     * {@link ArgParser} and {@code MethodHandle}s for the
     * implementation methods. The arguments described by the parser do
     * not include "self".
     * <p>
     * In the most common case, where {@code objclass} has only one
     * accepted implementation, there will be only one handle in the
     * {@code candidates} list. Where {@code objclass} has multiple
     * accepted implementations, {@code candidates} may have one entry
     * for each, although it is possible for a single entry with
     * {@code Object self}.
     *
     * @param objclass owning class
     * @param ap argument parser (provides name etc.)
     * @param candidates method handles for the implementations
     * @return a method descriptor supporting the signature
     */
    // Compare CPython PyDescr_NewMethod in descrobject.c
    static PyMethodDescr fromParser(PyType objclass, ArgParser ap, List<MethodHandle> candidates) {
        assert ap.methodKind == MethodKind.INSTANCE;
        /*
         * Note this is a recommendation on the assumption all optimisations
         * are supported. The actual choice is made in the switch statement.
         */
        MethodSignature sig = MethodSignature.fromParser(ap);

        try {
            if (objclass.acceptedCount == 1 && candidates.size() == 1) {
                /*
                 * Wrap the single candidate implementation of this method for the
                 * single accepted implementation of objclass. This is the most
                 * common case.
                 */
                MethodHandle mh = candidates.get(0);
                switch (sig) {
                    case NOARGS:
                        return new NoArgs(objclass, ap, mh);
                    case O1:
                        return new O1(objclass, ap, mh);
                    case O2:
                        return new O2(objclass, ap, mh);
                    case O3:
                        return new O3(objclass, ap, mh);
                    case POSITIONAL:
                        return new Positional(objclass, ap, mh);
                    default:
                        return new General(objclass, ap, mh);
                }
            } else {
                /*
                 * There are multiple accepted implementations of objclass. The
                 * constructors here match them to candidate implementations of ap.
                 * (We also land here if there is not exactly one candidate, relying
                 * on the search for one to fail and throw InternalError.)
                 */
                switch (sig) {
                    case NOARGS:
                        return new Multiple.NoArgs(objclass, ap, candidates);
                    case O1:
                        return new Multiple.O1(objclass, ap, candidates);
                    case O2:
                        return new Multiple.O2(objclass, ap, candidates);
                    case O3:
                        return new Multiple.O3(objclass, ap, candidates);
                    case POSITIONAL:
                        return new Multiple.Positional(objclass, ap, candidates);
                    default:
                        return new Multiple.General(objclass, ap, candidates);
                }
            }
        } catch (WrongMethodTypeException wmte) {
            throw new InterpreterError(wmte, "Failed to create descriptor for '%s.%s'",
                    objclass.name, ap.name);
        }
    }

    /**
     * Invoke the wrapped method handle for the given target
     * {@code self}, and standard arguments ({@code Object[]} and
     * {@code String[]}). The implementation will arrange the arguments
     * as expected by the handle, or throw if they are not correct for
     * that. In the general case, a call to {@link #argParser} is
     * involved. We create sub-classes of {@link PyMethodDescr} to
     * represent the finite repertoire of {@code MethodSignature}s, that
     * override this method with simplified logic.
     *
     * @param self target object of the method call
     * @param args arguments of the method call
     * @param names of arguments given by keyword or {@code null}
     * @return result of the method call
     * @throws TypeError when the arguments ({@code args} {@code names})
     *     are not correct for the method signature
     * @throws ArgumentError as a shorthand for {@link TypeError}, which
     *     the caller must convert with
     *     {@link MethodDescriptor#typeError(ArgumentError, Object[])}
     * @throws Throwable from the implementation of the method
     */
    // Compare CPython method_vectorcall_* in descrobject.c
    abstract Object callMethod(Object self, Object[] args, String[] names)
            throws ArgumentError, TypeError, Throwable;

    /**
     * Invoke the wrapped method handle for the given target
     * {@code self}, and arguments ({@code Object[]} given only by
     * position. Otherwise, this is the same as
     * {@link #callMethod(Object, Object[], String[])}.
     *
     * @param self target object of the method call
     * @param args arguments of the method call
     * @return result of the method call
     * @throws TypeError when the arguments ({@code args} are not
     *     correct for the method signature
     * @throws ArgumentError as a shorthand for {@link TypeError}, which
     *     the caller must convert with
     *     {@link MethodDescriptor#typeError(ArgumentError, Object[])}
     * @throws Throwable from the implementation of the method
     */
    // Compare CPython method_vectorcall_* in descrobject.c
    abstract Object callMethod(Object self, Object[] args)
            throws ArgumentError, TypeError, Throwable;

    /*
     * Having defined callMethod in which the first argument self is
     * given special treatment, we now provide a complete set of
     * implementations of call(...). These supersede the default
     * implementations given in FastCall. In FastCall, each makes an
     * array of its arguments for call(args), and ultimately we reach
     * call(args, null).
     *
     * Here instead we express each in terms of callMethod(self, args),
     * to avoid packing self into an array we then have to split. This
     * only has an effect where a sub-class does not further override
     * the method, to deal efficiently with a particular number of
     * positional arguments.
     */

    @Override
    public Object call(Object[] args, String[] names) throws TypeError, Throwable {
        int m = args.length - 1;
        if (m < 0) {
            // Not even one argument
            throw new TypeError(DESCRIPTOR_NEEDS_ARGUMENT, name, objclass.name);
        } else {
            // Split the leading element self from rest of args
            Object self = args[0], rest[];
            if (m == 0) {
                rest = Py.EMPTY_ARRAY;
            } else {
                rest = new Object[m];
                System.arraycopy(args, 1, rest, 0, m);
            }

            // Call this as a method bound to self.
            try {
                return callMethod(self, rest, names);
            } catch (ArgumentError ae) {
                throw typeError(ae, rest, names);
            }
        }
    }

    // call() throws so no need to optimise

    @Override
    public Object call(Object self) throws Throwable { return callMethod(self, Py.EMPTY_ARRAY); }

    @Override
    public Object call(Object self, Object a1) throws Throwable {
        return callMethod(self, new Object[] {a1});
    }

    @Override
    public Object call(Object self, Object a1, Object a2) throws Throwable {
        return callMethod(self, new Object[] {a1, a2});
    }

    @Override
    public Object call(Object self, Object a1, Object a2, Object a3) throws Throwable {
        return callMethod(self, new Object[] {a1, a2, a3});
    }

    /**
     * Return the handle contained in this descriptor applicable to the
     * Java class of a {@code self} argument during a call. In the base
     * implementation, this is by checking #objclass against the MRO of
     * {@code PyType.of(self)}. Sub-classes where {@code objclass} has
     * multiple accepted implementations override this method, because
     * they supersede {@link #method} with an array.
     * <p>
     * The {@link Descriptor#objclass} is consulted to make this
     * determination. If the class of {@code self} is not an accepted
     * implementation of {@code objclass}, an empty slot handle (with
     * the correct signature) is returned.
     *
     * @param self the {@code self} argument in some call
     * @return corresponding handle (or one that throws
     *     {@link EmptyException})
     * @throws TypeError if {@code self} is of unacceptable type
     * @throws Throwable on other errors while chasing the MRO
     */
    MethodHandle getHandle(Object self) throws TypeError, Throwable {
        /*
         * Note that when we override this descriptors supporting types with
         * multiple accepted implementations, we do not need to check along
         * the Python MRO since the outcome is guaranteed by the Java class
         * match.
         */
        // ??? At least, I think so.
        checkSelfType(self);
        return method;
    }

    // special methods ------------------------------------------------

    // Compare CPython method_repr in descrobject.c
    Object __repr__() { return descrRepr("method"); }

    /**
     * Invoke the Java method this method descriptor points to, using
     * the standard {@code __call__} arguments supplied, default
     * arguments and other information described in the associated
     * {@link #argParser} for the method.
     *
     * @param args all arguments beginning with {@code self}
     * @param names of keyword arguments
     * @return result of calling the wrapped method
     * @throws TypeError if {@code args[0]} is of the wrong type
     * @throws Throwable from the implementation of the special method
     */
    Object __call__(Object[] args, String[] names) throws TypeError, Throwable {
        try {
            if (names != null && names.length != 0) {
                return call(args, names);
            } else {
                int n = args.length;
                switch (n) {
                    // case 0 (an error) handled by default clause
                    case 1:
                        return call(args[0]);
                    case 2:
                        return call(args[0], args[1]);
                    case 3:
                        return call(args[0], args[1], args[2]);
                    case 4:
                        return call(args[0], args[1], args[2], args[3]);
                    default:
                        return call(args);
                }
            }
        } catch (ArgumentError ae) {
            throw typeError(ae, args);
        }
    }

    /*
     * A simplified __call__ used in the narrative. To use, rename this
     * to __call__, rename the real __call__ to something else, and
     * force fromParser() always to select General as the implementation
     * type.
     */
    Object simple__call__(Object[] args, String[] names) throws TypeError, Throwable {
        int m = args.length - 1, nk = names == null ? 0 : names.length;
        if (m < nk) {
            // Not even one argument (self) given by position
            throw new TypeError(DESCRIPTOR_NEEDS_ARGUMENT, name, objclass.name);
        } else {
            // Call this with self and rest of args separately.
            Object self = args[0];
            MethodHandle mh = getHandle(self);
            // Parse args without the leading element self
            Object[] frame = argParser.parse(args, 1, m, names);
            return mh.invokeExact(self, frame);
        }
    }

    /**
     * Return the described method, bound to {@code obj} as its "self"
     * argument, or if {@code obj==null}, return this descriptor. In the
     * non-null case, {@code __get__} returns a {@link PyJavaFunction}.
     * Calling the returned object invokes the same Java method as this
     * descriptor, with {@code obj} as first argument, and other
     * arguments to the call appended.
     *
     * @param obj target (self) of the method, or {@code null}
     * @param type ignored
     * @return method bound to {@code obj} or this descriptor.
     * @throws TypeError if {@code obj!=null} is not compatible
     * @throws Throwable on other errors while chasing the MRO
     */
    @Override
    // Compare CPython method_get in descrobject.c
    Object __get__(Object obj, PyType type) throws TypeError, Throwable {
        if (obj == null)
            // Return the descriptor itself.
            return this;
        else {
            // Return a callable binding the method and the target
            check(obj);
            return PyJavaFunction.from(this, obj);
        }
    }

    // exposed methods -----------------------------------------------

    /** @return name of the function or method */
    // Compare CPython meth_get__name__ in methodobject.c
    // @Exposed.Getter
    String __name__() { return argParser.name; }

    // Compare CPython method_get_doc in descrobject.c
    Object get_doc() { return PyType.getDocFromInternalDoc(__name__(), argParser.doc); }

    // Compare CPython method_get_text_signature in descrobject.c
    Object get_text_signature() {
        return PyType.getTextSignatureFromInternalDoc(__name__(), argParser.doc);
    }

    // plumbing ------------------------------------------------------

    /**
     * Construct an array of method handles, one for each accepted
     * implementation of {@code objclass}, working from a list of
     * candidate method handles.
     *
     * @param sig handle type information distilled from parser
     * @param candidates handles on which to base return
     * @return method handles aligned to {@code objclass.clases}
     */
    protected MethodHandle[] prepareCandidates(MethodSignature sig, List<MethodHandle> candidates) {

        final int N = objclass.acceptedCount;
        MethodHandle[] methods = new MethodHandle[N];

        // Fill the method array with matching method handles
        for (int i = 0; i < N; i++) {
            // Seek most specific match for the i.th accepted class
            Class<?> ac = objclass.classes[i];
            MethodHandle match = null;
            // The candidates are sorted most specific first
            for (MethodHandle mh : candidates) {
                MethodType mt = mh.type();
                if (mt.parameterType(0).isAssignableFrom(ac)) {
                    match = mh;
                    break;
                }
            }

            if (match != null) {
                /*
                 * Prepare the implementation handle to match the invocation type in
                 * callMethod.
                 */
                methods[i] = sig.prepare(argParser, match);
            } else {
                // No match means no implementation we can use
                throw new InterpreterError("'%s.%s' not implemented for %s", objclass.name,
                        __name__(), objclass.classes[i]);
            }
        }
        return methods;
    }

    /**
     * Make sure that the argument is acceptable as 'self' by checking
     * against the MRO of {@code PyType.of(self)}.
     *
     * @param self to be checked
     * @throws TypeError if it is of unacceptable type
     * @throws Throwable on other errors while chasing the MRO
     */
    protected final void checkSelfType(Object self) throws TypeError, Throwable {
        // Make sure that the argument is acceptable as 'self'
        PyType selfType = PyType.of(self);
        if (selfType == objclass || Abstract.recursiveIsSubclass(selfType, objclass)) {
            return;
        } else {
            throw selfTypeError(self);
        }
    }

    protected TypeError selfTypeError(Object self) {
        PyType selfType = PyType.of(self);
        return new TypeError(DESCRIPTOR_REQUIRES, name, objclass.name, selfType.name);
    }

    /**
     * The implementation may have any signature supportable in Python
     * by {@link ArgParser}. {@link #fromParser(PyType, ArgParser, List)
     * fromParser()} will choose a {@code General} representation of the
     * method when no optimisations apply.
     */
    private static class General extends PyMethodDescr {
        /**
         * Construct a method descriptor, identifying the implementation by
         * a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method handle to invoke the wrapped method or {@code null}
         *     signifying a matching empty handle.
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        General(PyType objclass, ArgParser argParser, MethodHandle method) {
            super(objclass, argParser, MethodSignature.GENERAL, method);
        }

        /**
         * {@inheritDoc}
         * <p>
         * Exceptionally, it pays to override the inherited implementation
         * here because we have to use the fully general {@link ArgParser}
         * and it is able to work on the slice {@code args[1:]} without a
         * copy.
         */
        @Override
        public Object call(Object[] args, String[] names) throws ArgumentError, Throwable {
            // Call this with self and rest of args separately.
            checkHasSelf(args, names);
            Object self = args[0];
            MethodHandle mh = getHandle(self);
            // Parse args without the leading element self
            Object[] frame = argParser.parse(args, 1, args.length - 1, names);
            return mh.invokeExact(self, frame);
        }

        /**
         * {@inheritDoc}
         * <p>
         * Exceptionally, it pays to override the inherited implementation
         * here because we have to use the fully general {@link ArgParser}
         * and it is able to work on the slice {@code s[p+1:p+n]} without a
         * copy.
         */
        @Override
        public Object vectorcall(Object[] s, int p, int n, String[] names)
                throws ArgumentError, Throwable {
            int m = n - 1, nk = names == null ? 0 : names.length;
            if (m < nk) {
                // Not even one argument (self) given by position
                throw new ArgumentError(Mode.SELF);
            }
            // Call this with self separated.
            Object self = s[p];
            MethodHandle mh = getHandle(self);
            // Parse args without the leading element self
            Object[] frame = argParser.parse(s, p + 1, m, names);
            return mh.invokeExact(self, frame);
        }

        /** Equivalent to {@code vectorcall(s, p, n, null)}. */
        @Override
        public Object vectorcall(Object[] s, int p, int n) throws ArgumentError, Throwable {
            return vectorcall(s, p, n, null);
        }

        @Override
        Object callMethod(Object self, Object[] args, String[] names) throws TypeError, Throwable {
            /*
             * The method handle type is (O,O[])O. The parser will make an array
             * of the args, gather excess arguments into a tuple or dict (where
             * allowed), and fill missing ones from defaults.
             */
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.GENERAL.instanceType;
            Object[] frame = argParser.parse(args, names);
            return mh.invokeExact(self, frame);
        }

        @Override
        Object callMethod(Object self, Object[] args) throws TypeError, Throwable {
            return callMethod(self, args, null);
        }
    }

    /**
     * Base class for methods that accept between defined maximum and
     * minimum numbers of arguments {@code self}, that must be given by
     * position. Maximum and minimum may be equal to a single acceptable
     * number.
     * <p>
     * Arguments may not be given by keyword. There is no excess
     * argument (varargs) collector.
     * <p>
     * The number of arguments required by the wrapped Java method sets
     * a maximum allowable number of arguments. Fewer arguments than
     * this may be given, to the extent that defaults specified by the
     * parser make up the difference. The number of available defaults
     * determines the minimum number of arguments to be supplied.
     */
    private static abstract class AbstractPositional extends PyMethodDescr {

        /** Default values of the trailing arguments. */
        protected final Object[] d;

        /** Minimum number of positional arguments in a call. */
        protected final int min;

        /** Maximum number of positional arguments in a call. */
        protected final int max;

        /**
         * Construct a method descriptor, identifying the implementation by
         * a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param signature to which to coerce the handle
         * @param method handle to invoke the wrapped method or {@code null}
         *     signifying the empty handle.
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        AbstractPositional(PyType objclass, ArgParser argParser, MethodSignature signature,
                MethodHandle method) {
            super(objclass, argParser, signature, method);
            assert !argParser.hasVarArgs();
            // Cardinal values for positional argument processing
            this.d = argParser.getDefaults();
            this.max = argParser.argcount;
            this.min = argParser.argcount - d.length;
        }

        @Override
        Object callMethod(Object self, Object[] args, String[] names) throws TypeError, Throwable {
            if (names == null || names.length == 0) {
                return callMethod(self, args);
            } else {
                // The self-type error takes precedence if both.
                checkSelfType(self);
                throw new ArgumentError(Mode.NOKWARGS);
            }
        }

        @Override
        public Object call(Object[] args) throws TypeError, Throwable {
            int m = args.length - 1;
            if (m < 0) {
                // Not even one argument
                throw new TypeError(DESCRIPTOR_NEEDS_ARGUMENT, name, objclass.name);
            } else {
                // Split the leading element self from rest of args
                Object self = args[0], rest[];
                if (m == 0) {
                    rest = Py.EMPTY_ARRAY;
                } else {
                    rest = new Object[m];
                    System.arraycopy(args, 1, rest, 0, m);
                }

                // Call this as a method bound to self.
                try {
                    return callMethod(self, rest);
                } catch (ArgumentError ae) {
                    throw typeError(ae, rest);
                }
            }
        }
    }

    /**
     * A method represented by {@code NoArgs} accepts <b>no</b>
     * arguments after {@code self}, by position or keyword.
     * <p>
     * {@link #fromParser(PyType, ArgParser, List)} will only choose a
     * {@code NoArgs} (or sub-class) representation of the method when
     * this condition applies.
     */
    private static class NoArgs extends AbstractPositional {
        /**
         * Construct a method descriptor, identifying the implementation by
         * a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method handle to invoke the wrapped method or {@code null}
         *     signifying a matching empty handle.
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        NoArgs(PyType objclass, ArgParser argParser, MethodHandle method) {
            super(objclass, argParser, MethodSignature.NOARGS, method);
            assert max == 0;
            assert max - min == d.length;
        }

        @Override
        Object callMethod(Object self, Object[] args) throws TypeError, Throwable {
            // The method handle type is (O)O (no args after self).
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.NOARGS.instanceType;
            return mh.invokeExact(self);
        }

        @Override
        public Object call(Object self) throws Throwable {
            // The method handle type is (O)O.
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.NOARGS.instanceType;
            return mh.invokeExact(self);
        }
    }

    /**
     * The implementation signature requires {@code self} and one
     * argument, which may be supplied by
     * {@link ArgParser#getDefaults()}.
     */
    private static class O1 extends AbstractPositional {

        /**
         * Construct a method descriptor, identifying the implementation by
         * a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method handle to invoke the wrapped method or {@code null}
         *     signifying a matching empty handle.
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        O1(PyType objclass, ArgParser argParser, MethodHandle method) {
            super(objclass, argParser, MethodSignature.O1, method);
            assert max == 1;
            assert max - min == d.length;
        }

        @Override
        Object callMethod(Object self, Object[] a) throws TypeError, Throwable {
            // The method handle type is (O,O)O.
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O1.instanceType;
            int n = a.length;
            if (n == 1) {
                // Number of arguments matches number of parameters
                return mh.invokeExact(self, a[0]);
            } else if (n == min) {
                // Since min<=max, max==1 and n!=1, we have n==min==0
                return mh.invokeExact(self, d[0]);
            }
            // n < min || n > max
            throw new ArgumentError(min, max);
        }

        @Override
        public Object call(Object self) throws Throwable {
            MethodHandle mh = getHandle(self);
            if (min > 0) { throw new ArgumentError(min, 1); }
            return mh.invokeExact(self, d[0]);
        }

        @Override
        public Object call(Object self, Object a1) throws Throwable {
            MethodHandle mh = getHandle(self);
            return mh.invokeExact(self, a1);
        }
    }

    /**
     * The implementation signature requires {@code self} and two
     * arguments, which may be supplied by
     * {@link ArgParser#getDefaults()}.
     */
    private static class O2 extends AbstractPositional {

        /**
         * Construct a method descriptor, identifying the implementation by
         * a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method handle to invoke the wrapped method or {@code null}
         *     signifying a matching empty handle.
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        O2(PyType objclass, ArgParser argParser, MethodHandle method) {
            super(objclass, argParser, MethodSignature.O2, method);
            assert max == 2;
            assert max - min == d.length;
        }

        @Override
        Object callMethod(Object self, Object[] a) throws ArgumentError, TypeError, Throwable {
            // The method handle type is (O,O,O)O.
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O2.instanceType;
            int n = a.length, k;
            if (n == 2) {
                // Number of arguments matches number of parameters
                return mh.invokeExact(self, a[0], a[1]);
            } else if ((k = n - min) >= 0) {
                if (n == 1) {
                    return mh.invokeExact(self, a[0], d[k]);
                } else if (n == 0)
                    return mh.invokeExact(self, d[k++], d[k]);
            }
            // n < min || n > max
            throw new ArgumentError(min, max);
        }

        @Override
        public Object call(Object self) throws Throwable {
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O2.instanceType;
            if (min == 0) { return mh.invokeExact(self, d[0], d[1]); }
            throw new ArgumentError(min, max);
        }

        @Override
        public Object call(Object self, Object a1) throws Throwable {
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O2.instanceType;
            int k = 1 - min;
            if (k >= 0) { return mh.invokeExact(self, a1, d[k]); }
            throw new ArgumentError(min, max);
        }

        @Override
        public Object call(Object self, Object a1, Object a2) throws Throwable {
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O2.instanceType;
            return mh.invokeExact(self, a1, a2);
        }
    }

    /**
     * The implementation signature requires {@code self} and three
     * arguments, which may be supplied by
     * {@link ArgParser#getDefaults()}.
     */
    private static class O3 extends AbstractPositional {

        /**
         * Construct a method descriptor, identifying the implementation by
         * a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method handle to invoke the wrapped method or {@code null}
         *     signifying a matching empty handle.
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        O3(PyType objclass, ArgParser argParser, MethodHandle method) {
            super(objclass, argParser, MethodSignature.O3, method);
            assert max == 3;
            assert max - min == d.length;
        }

        @Override
        Object callMethod(Object self, Object[] a) throws ArgumentError, TypeError, Throwable {
            // The method handle type is (O,O,O,O)O.
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O3.instanceType;
            int n = a.length, k;
            if (n == 3) {
                // Number of arguments matches number of parameters
                return mh.invokeExact(self, a[0], a[1], a[2]);
            } else if ((k = n - min) >= 0) {
                if (n == 2) {
                    return mh.invokeExact(self, a[0], a[1], d[k]);
                } else if (n == 1) {
                    return mh.invokeExact(self, a[0], d[k++], d[k]);
                } else if (n == 0)
                    return mh.invokeExact(self, d[k++], d[k]);
            }
            // n < min || n > max
            throw new ArgumentError(min, max);
        }

        @Override
        public Object call(Object self) throws Throwable {
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O3.instanceType;
            if (min == 0) { return mh.invokeExact(self, d[0]); }
            throw new ArgumentError(min, max);
        }

        @Override
        public Object call(Object self, Object a1) throws Throwable {
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O3.instanceType;
            int k = 1 - min;
            if (k >= 0) { return mh.invokeExact(self, a1, d[k++], d[k]); }
            throw new ArgumentError(min, max);
        }

        @Override
        public Object call(Object self, Object a1, Object a2) throws Throwable {
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O3.instanceType;
            int k = 2 - min;
            if (k >= 0) { return mh.invokeExact(self, a1, a2, d[k]); }
            throw new ArgumentError(min, max);
        }

        @Override
        public Object call(Object self, Object a1, Object a2, Object a3) throws Throwable {
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.O3.instanceType;
            return mh.invokeExact(self, a1, a2, a3);
        }
    }

    /**
     * A method represented by {@code Positional} only accepts arguments
     * after {@code self} given by position. The constraints detailed
     * for {@link AbstractPositional} apply.
     * <p>
     * {@link #fromParser(PyType, ArgParser, List) fromParser()} will
     * only choose a {@code Positional} (or sub-class) representation of
     * the method when these conditions apply.
     */
    private static class Positional extends AbstractPositional {

        /**
         * Construct a method descriptor, identifying the implementation by
         * a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method handle to invoke the wrapped method or {@code null}
         *     signifying the empty handle.
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        Positional(PyType objclass, ArgParser argParser, MethodHandle method) {
            super(objclass, argParser, MethodSignature.POSITIONAL, method);
            assert max == argParser.argcount;
            assert max - min == d.length;
        }

        @Override
        Object callMethod(Object self, Object[] a) throws TypeError, Throwable {
            // The method handle type is (O,O[])O.
            MethodHandle mh = getHandle(self);
            assert mh.type() == MethodSignature.POSITIONAL.instanceType;
            int n = a.length, k;
            if (n == max) {
                // Number of arguments matches number of parameters
                return mh.invokeExact(self, a);
            } else if ((k = n - min) >= 0) {
                // Concatenate a[:] and defaults[k:]
                Object[] frame = new Object[max];
                System.arraycopy(a, 0, frame, 0, n);
                System.arraycopy(d, k, frame, n, max - n);
                return mh.invokeExact(self, frame);
            }
            // n < min || n > max
            throw new ArgumentError(min, max);
        }
    }

    /**
     * A name space for sub-classes of {@link PyMethodDescr} to use for
     * an instance method when the owning Python type has multiple
     * accepted implementations.
     */
    private static class Multiple {

        /**
         * A variant of {@link PyMethodDescr.General} that allows for
         * multiple accepted implementations of {@code objclass}.
         */
        private static class General extends PyMethodDescr.General {
            /**
             * Handles for the particular implementations of a method. The
             * method type of each is the same as {@link PyMethodDescr#method},
             * which itself will be set to "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.General} that allows for multiple accepted
             * implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            General(PyType objclass, ArgParser argParser, List<MethodHandle> candidates) {
                super(objclass, argParser, null);
                this.methods = prepareCandidates(MethodSignature.GENERAL, candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    throw selfTypeError(self);
                }
            }
        }

        /**
         * A variant of {@link PyMethodDescr.NoArgs} that allows for
         * multiple accepted implementations of {@code objclass}.
         */
        static class NoArgs extends PyMethodDescr.NoArgs {
            /**
             * Handles for the particular implementations of a method. The
             * method type of each is the same as {@link PyMethodDescr#method},
             * which itself will be set to "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.General} that allows for multiple accepted
             * implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            NoArgs(PyType objclass, ArgParser argParser, List<MethodHandle> candidates) {
                super(objclass, argParser, null);
                this.methods = prepareCandidates(MethodSignature.NOARGS, candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    throw selfTypeError(self);
                }
            }
        }

        /**
         * A variant of {@link PyMethodDescr.O1} that allows for multiple
         * accepted implementations of {@code objclass}.
         */
        static class O1 extends PyMethodDescr.O1 {
            /**
             * Handles for the particular implementations of a method. The
             * method type of each is the same as {@link PyMethodDescr#method},
             * which itself will be set to "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.O1} that allows for multiple accepted
             * implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O1(PyType objclass, ArgParser argParser, List<MethodHandle> candidates) {
                super(objclass, argParser, null);
                this.methods = prepareCandidates(MethodSignature.O1, candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    throw selfTypeError(self);
                }
            }
        }

        /**
         * A variant of {@link PyMethodDescr.O2} that allows for multiple
         * accepted implementations of {@code objclass}.
         */
        static class O2 extends PyMethodDescr.O2 {
            /**
             * Handles for the particular implementations of a method. The
             * method type of each is the same as {@link PyMethodDescr#method},
             * which itself will be set to "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.O1} that allows for multiple accepted
             * implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O2(PyType objclass, ArgParser argParser, List<MethodHandle> candidates) {
                super(objclass, argParser, null);
                this.methods = prepareCandidates(MethodSignature.O2, candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    throw selfTypeError(self);
                }
            }
        }

        /**
         * A variant of {@link PyMethodDescr.O3} that allows for multiple
         * accepted implementations of {@code objclass}.
         */
        static class O3 extends PyMethodDescr.O3 {
            /**
             * Handles for the particular implementations of a method. The
             * method type of each is the same as {@link PyMethodDescr#method},
             * which itself will be set to "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.O1} that allows for multiple accepted
             * implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O3(PyType objclass, ArgParser argParser, List<MethodHandle> candidates) {
                super(objclass, argParser, null);
                this.methods = prepareCandidates(MethodSignature.O3, candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    throw selfTypeError(self);
                }
            }
        }

        /**
         * A variant of {@link PyMethodDescr.Positional} that allows for
         * multiple accepted implementations of {@code objclass}.
         */
        static class Positional extends PyMethodDescr.Positional {
            /**
             * Handles for the particular implementations of a method. The
             * method type of each is the same as {@link PyMethodDescr#method},
             * which itself will be set to "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.Positional} that allows for multiple
             * accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            Positional(PyType objclass, ArgParser argParser, List<MethodHandle> candidates) {
                super(objclass, argParser, null);
                this.methods = prepareCandidates(MethodSignature.POSITIONAL, candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    throw selfTypeError(self);
                }
            }
        }
    }
}
