# base.py: foundations for source-code generation from templates

# Copyright (c)2021 Jython Developers.
# Licensed to PSF under a contributor agreement.

# Module: evo1.generate.base

from dataclasses import dataclass
from enum import Enum
from datetime import datetime


# The method implementations convert operands to a common "working
# type" in order to perform the central operation. The type varies
# with the operation and the operand(s). For example, when adding
# two operands known to be Integer, the common type is LONG (Java
# long), so that there is no overflow, while bit-wise operations on
# the same pair may be carried out in an INT.
#
# In a unary operation, the wider of the (minimum) operation type
# and the operand type is used. When mixing types in a binary
# operation, the widest of the two types and the operation is used.
class WorkingType(Enum):
    "Enumerates the types to which operands may be converted."
    BOOLEAN = 0
    INT = 1
    LONG = 2
    BIG = 3
    DOUBLE = 4
    STRING = 5
    SEQ = 6
    OBJECT = 7


# We use pre-defined data classes to describe (Java) types that may
# appear as operands or return types. We record the name in Java,
# information about the minimum "width" at which we ought to
# compute with them, and how to convert them to int, long and big
# representations.

@dataclass
class TypeInfo:
    "Information about a type an templates for conversion to int types"
    # Java name of a Java class ("PyLong", "Integer", etc.)
    name: str
    # An argument of this type implies the working type is at least:
    min_working_type: WorkingType


# Implementation template scripts extend this dataclass to describe
# their operations.

@dataclass
class OpInfo:
    "Base class for describing operations."
    # Name of the operation ("__add__", "__neg__", etc.).
    name: str
    # An implementation of this op has a return type of:
    return_type: TypeInfo
    # Implementation of this op implies the working type is at least:
    min_working_type: WorkingType


# Base class of generators for object implementations

class ImplementationGenerator:

    # Adjust the indent to match that requested
    def set_indent(self, i):
        self.emitter.indent = i

    # Create a warning comment
    def emit_object_template(self, e, src):
        name = getattr(src, 'name', '?').replace('\\', '/')
        e.emit_line("/*")
        e.emit_line(" * Generated by java_object_gen using ")
        e.emit(f"generator {self.__class__.__name__}.")
        e.emit_line(f" * Source: {name}")
        timestamp = datetime.now().strftime("%A %Y-%m-%d %H:%M:%S")
        e.emit_line(f" * Date: {timestamp}")
        e.emit_line(" */")

    # Emit a rule (comment) above a block of implementations
    def emit_heading(self, e, name:str):
        e.emit_line(f'// {"-"*(60-len(name))} {name}')
        e.emit_line()

    # Emit methods selectable by a single type
    def special_methods(self, e):
        pass

    # Emit methods selectable by a pair of types (for call sites)
    def special_binops(self, e):
        pass

    def emit_object_plumbing(self, e):
        pass

    def left_justify(self, text):
        "Left-justify a block of text, returning a list of lines."
        lines = list()
        # Find common leading indent
        common = 999
        for line in text.splitlines():
            # Discard trailing space
            line = line.rstrip()
            # Discard empty lines
            if (n:=len(line)) > 0:
                space = n - len(line.lstrip())
                if space < common: common = space
                lines.append(line)
        if common == 999: common = 0
        # Remove this common prefix
        clean = list()
        for line in lines:
            clean.append(line[common:])
        return clean


