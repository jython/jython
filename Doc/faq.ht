Title: Jython FAQ

<h3>The Jython FAQ</h3>

<ol>
<li><b>What is JPython?</b>

    <p>JPython is a new implementation of the Python programming
    language which is designed to run on the Java(tm) Platform.  It
    consists of a compiler to compile Python source code down to Java
    bytecodes which can run directly on a JVM, a set of support
    libraries which are used by the compiled Java bytecodes, and extra
    support to make it trivial to use Java packages from within
    JPython.

<p><li><b>What is Jython?</b>

    <p>Jython is the successor to JPython. The Jython project was
    created in accordance with the CNRI JPython 1.1.x license, in
    order to ensure the continued existence and development of this
    important piece of Python software.  The intent is to manage this
    project with the same open policies that are serving CPython so well.

    <p>Mailing lists, CVS and all current information on the Jython
    project is available at SourceForge, at 
    <a href="http://sourceforge.net/projects/jython">The Jython project</a>.

<p><li><b>Is Jython the same language as Python?</b>
    <P>We will always strive to ensure that Jython remains as
    compatible with CPython as possible.  Nevertheless, there are a
    number of
    <a href="differences.html">differences</a>
    between the two implementations that are
    unlikely to go away.  These range from the trivial - Jython's
    code objects don't have a co_code attribute because they don't
    have any Python bytecodes; to the significant - Jython uses
    Java's true garbage collection rather than Python's reference
    counting scheme.

    <P>Python has never really had much of a language definition
    beyond it's C-based implementation.  The existence of Jython
    changed that for the first time and will hopefully lead to a much
    clearer sense of what Python the language is; independent of any
    specific implementation.

    <P>We will be preparing a version of Python's regression test that
    would be appropriate for new implementations of the language.
    This is a good first step towards defining what parts of Python
    are essential and which are incidental.

<p><li><b>What is the current status of JPython?</b>
    <p>JPython 1.1 was released on 28-Jan-2000. Since then, there have 
    been no further developments on JPython.

<p><li><b>What is the current status of Jython?</b>
    <p>The Jython project was announced on 19-oct-2000. A release of 
    jython-2.0 is planned before the end of the year.

<p><li><b>JPython and Y2K</b>

    <p>The standard response to queries about JPython's Y2K compliance 
    points you to the
    <a href="http://www.python.org/cgi-bin/faqw.py?querytype=anykeywords&casefold=yes&req=search&query=y2k">
    Python FAQ entry on the subject</a>, with the additional caveat
    that Jython is of course dependent on any Y2K issues associated
    with the underlying JVM and Java class libraries you're using.
    However, you can essentially apply the Python Y2K stance to
    Jython by, e.g. substituting the word "Java" for "C" in FAQ
    question 4.65 (<em>ignore the clip from the Python copyright
    notice</em>).

<p><li><b><A NAME="Supported Modules"></A>What parts of the Python
    library are supported?</b>

    <P>The good news is that Jython now supports the large majority
    of the standard Python library.  The bad news is that this has
    moved so rapidly, it's hard to keep the documentation up to
    date.

    <p>Built-in modules (e.g. those that are written in C for CPython) 
    are a different story.  These would have to be ported to Java, or
    implemented with a JNI bridge in order to be used by JPython.
    Some built-in modules have been ported to JPython, most notably
    cStringIO, cPickle, struct, and binascii (donated by Finn Bock).
    It is unlikely that JNI modules will be included in JPython proper 
    though.</P>

    <P>If you want to use a standard Python module, just try importing
    it.  If it that works you're probably all set.  You can also do a
    dir() on the modules to check the list of functions it
    implements.</P>

    <P>If there is some standard Python module that you have a real
    need for that doesn't work with JPython yet, please
    <a href="mailto:jython-dev@lists.sourceforge.net">send us mail</a>.

<p><li><b>How fast is Jython?</b>

    <p>At <a href="http://www.python.org/workshops/1997-10/">IPC-6</a>
    JimH reported speeds equal to CPython 1.4 on the pystone
    benchmark.  When Guido released CPython 1.5 he succeeded in making
    it about 2x faster than the 1.4 release.  The current release of
    CPython is 1.5.2 which might be only slightly faster than 1.5.
    JimH re-ran his benchmark tests against CPython 1.5 and his then
    current release of Jython, finding that Jython was about 2.5x
    slower than CPython 1.5.  I have recently run a few informal
    benchmarks and found some interesting numbers: using Sun's JDK
    1.2.1 with JIT on a Solaris 2.6 Sparc Ultra 2, I found Jython
    1.1beta3 to produce pystone numbers equal to (or very slightly
    better than) CPython 1.5.2+.

    <p>The problem, of course, is that JITs are still not reliable
    enough for Jython.  Turning off the JIT on the above platform,
    can slow Jython down by a factor of 10.

    <P>The speed of Jython is tied very tightly to the speed of the
    underlying JVM.  The benchmark results that JimH reported were all
    using Microsoft's JVM from Internet Explorer 4.0.  The next
    fastest JVM that he used was almost a factor of 2 slower than
    this.  Since the performance of JVMs changes nearly every day, at
    some point I'll need to collect a set of scores comparing pystone
    performance on a wider variety of JVM's.</P>

    <P>Finally, pystone is not the last word in benchmarking.  At the
    moment I'm more concerned with making Jython complete and correct
    than with performance.  We will continually be revisiting
    performance issues both to examine better benchmark's for
    comparing Jython and CPython (as well as other scripting
    languages for the JVM) and work at optimizing Jython's
    performance.

<p><li><b>Why do weird things sometimes happen in Jython?</b>

    <p>More likely than not, the problem is with the JIT
    (Just-in-time) compiler your JVM is using.  Jython acts
    like a bizarre Java compiler, taking Python source code and
    emitting Java bytecode.  It's bizarre because the emitted bytecode
    doesn't look quite like the way bytecode would come out of a Java
    compiler.  JITs can sometimes get confused by this and will often
    do incorrect and inexplicable things.  If you're seeing strange
    stuff happen, or weird bugs, the first thing to do is to turn off
    your JIT and try again.  If the bug still exists with the JIT
    turned off then consider 
    <a href="http://sourceforge.net/bugs/?group_id=12867">submitting a 
    bug report</a>.

<p><li><b>Why did I get an OutOfMemoryError?</b>

    <P>If you are using Sun's Java VM (or a derived VM) the virtual
    machine sets a default memory limit of 16 MB.  This can be very
    confusing when you are running on a machine with 128 MB of RAM and
    you see an OutOfMemoryError after having used only 17 MB.</P>

    <P>You can increase this memory limit by adding the following
    switch to the call that invokes the Java VM (you need to modify
    the jpython launch script):</P>

<pre>
    jre -mx32m &lt;...&gt;
</pre>

    <P>This will set your upper memory limit to 32 MB.  Obviously,
    higher limits should be used if required by your program - and
    supported by your computer..

<p><li><b>Why can't I use "from java import ..." on Windows?"</b>

    <p>This problem can occur if you are using Microsoft's VM
    (i.e. <tt>jview.exe</tt>) which provides the standard classes in a 
    different format.  You need to run the following command in a
    console window before using Jython:

<pre>
    clspack -auto
</pre>

<p><li><b>Semantic Differences between Jython and CPython</b>

    <P>There are several several differences between Jython and
    CPython that wil probably never go away.  These differences are
    primarily related to underlying differences between the C and Java
    programming languages/environments.  See <a
    href="differences.html">a more detailed list</a> of these
    differences.  In brief though, here are two of the more obvious
    differences you'll notice:

    <p><UL>
	<LI><em>Jython has true garbage collection - CPython uses
	reference counting.</em>

	<br>This means that in Jython users don't need to worry about
	    creating circular references as these are guarnteed to be
	    collected properly.  On the other hand, users of Jython have
	    no guarantees of when an object will be finalized (short of
	    calling System.gc() to force garbage collection).
	    Theoretically, this might cause problems for users who were
	    depending on CPython's finalization timing to free limited
	    system resources.  Also, because of the severe performance 
	    hit when providing non-trivial Java <tt>finalize()</tt>
	    methods, no Python object's <tt>__del__()</tt> method is
	    ever called.

	<p><LI><em>Control-C can not be caught by Jython, but will exit the
	    shell completely</em>
    </UL>

<p><li><b>Why can't I multiply inherit from two Java classes?</b>

    <P>In earlier versions of JPython, you actually could.  This was
    deliberately disabled in 1.1 for a variety of good reasons. For a
    detailed discussion on this issue see the following archive
    messages:

    <p><a
    href="http://www.python.org/pipermail/jpython-interest/1998-April/000213.html">http://www.python.org/pipermail/jpython-interest/1998-April/000213.html</a><br>
    <a href="http://www.python.org/pipermail/jpython-interest/1999-January/001162.html">http://www.python.org/pipermail/jpython-interest/1999-January/001162.html</a>

    <p>Note that you can still multiply inherit from any number of
    Python classes.

<p><li><b>Why does dir(someJavaObject) return the empty list?</b>

    <p>Because the built-in <tt>dir()</tt> function returns
    a list of names culled from the object's <tt>__dict__</tt>,
    <tt>__methods__</tt>, and <tt>__members__</tt> attributes.  In
    Python, an instance's methods live in the instance's class's
    dictionary, so dir(someJavaObject.__class__) would return a list
    of the method names (although only for the direct class, not for
    any base classes).

</ol>
